<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cocos2d-x | 谙忆-人生之旅]]></title>
  <link href="http://chenhaoxiang.github.io/blog/categories/cocos2d-x/atom.xml" rel="self"/>
  <link href="http://chenhaoxiang.github.io/"/>
  <updated>2017-08-24T00:36:05+08:00</updated>
  <id>http://chenhaoxiang.github.io/</id>
  <author>
    <name><![CDATA[陈浩翔]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【Cocos2d-x】开发实战-Cocos中的字符串、标签和中文乱码]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/06/27/cocos2d-string-label-mojibake/"/>
    <updated>2017-06-27T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/06/27/cocos2d-string-label-mojibake</id>
    <content type="html"><![CDATA[<p>本篇博客讲解:<br/>
1.Ccocos2d-x中的字符串
2.使用标签
3.中文乱码问题</p>

<!-- more -->


<hr />

<p>[TOC]</p>

<h1>Ccocos2d-x中的字符串</h1>

<h2>使用const char*和std::string</h2>

<p>const char<em>是C风格的字符串<br/>
std::string是C++风格的字符串，它封装了const char</em><br/>
初始化std::string对象:
```C++ 初始化std::string对象
std::string name = &ldquo;jack&rdquo;;//直接赋值
std::string name = std::string(&ldquo;jack&rdquo;);//通过构造函数初始化</p>

<p>//创建对象通过静态方法创建，也就是在程序结束的时候，或者超过作用域的时候，自动释放，这就不需要我们来关心对象的释放
<code>
std::string 指针类型
</code>C++ std::string 指针类型
std::string<em> namep = new std::string(&ldquo;jack&rdquo;);
//new 代表创建这个对象是动态创建的，是在程序运行过程中创建的，使用完成之后需要delete删除。
//返回值不是对象本身，而是指向对象的指针
&hellip;
delete namep;
<code>
把std::string 转化为const char*类型
</code>C++ 把std::string 转化为const char</em>类型
const char<em> cstring = name.c_str();//静态方法创建
const char</em> cstring = namep->c_str();//namep为指针
```</p>

<pre><code>std::string name = "jack";//直接赋值

log("name = %s",name);//直接这样会出现乱码问题，因为log用的不对
//我们可以去看log函数:void CC_DLL log(const char * format, ...) CC_FORMAT_PRINTF(1, 2);类型是const char*

log("name = %s", name.c_str());

std::string *name1 = new std::string("jack");//直接赋值    
log("name1 = %s", name1-&gt;c_str());
</code></pre>

<h2>使用cocos2d::__String</h2>

<p>(注意是两个英文下划线)
源自于Objective-C的NSString<br/>
在coco2d-x里面，凡是有两个下划线开头的，都是过渡Objective-C过来的(内存管理采用引用计数管理)<br/>
现在Cocos2d-x在慢慢去除Objective-C化</p>

<p><img src="http://i.imgur.com/3wvkHJl.png" alt="" /></p>

<p>创建它的主要的静态create函数如下(工厂设计模式)
<code>
static __String *create(const std::string &amp;str)
static __String *createWithFormat(const char *format,...)
//createWithFormat-通过创建模板来创建字符串，所以可以通过这个方法把其他类型的转换为字符串
</code></p>

<h3>数据类型之间的转换</h3>

<p>cocos2d::__String 转换为const cahr*类型，这种转换还是用的比较多的<br/>
<code>C++ cocos2d::__String 转换为const cahr*类型
__String *name = __String::create("Hi,Tony");//得到对象指针，因为是通过静态create函数获取的，不需要我们delete
const char *cstring = name-&gt;getCString();
</code></p>

<p>const cahr* 转换为cocos2d::__Stirng类型
<code>C++ const cahr* 转换为cocos2d::__Stirng类型
const char* cstring ="Hi,Tonny";
__String *ns = __String::createWithFormat("%s",cstring);
</code></p>

<p>std::string转换为cocos2d::__String类型
<code>C++ std::string转换为cocos2d::__String类型
std::string string = "Hi,Tonny";
__String *name4 = __String::createWithFormat("%s", string.c_str());//将std::string转换为__String
</code></p>

<p>cocos2d::__String转换为int类型
<code>C++ cocos2d::__String转换为int类型
int num = 123;
__String *ns = __String::createWithFormat("%d",num);//这种方式可以转换很多其他类型
int num2 = ns-&gt;intValue();
</code></p>

<h2>Win32平台下中文乱码问题</h2>

<p>默认情况下Windows中文环境是采用GBK编码，源程序文件HelloWorldScene.cpp编码默认也是GBK，如果源程序代码中有中文，它的字符集是GBK，我们需要将中文符GBK编码转换为UTF-8编码。</p>

<h3>解决方法一</h3>

<p>源文件保存为UTF-8(不带签名的)<br/>
文件->高级保存选项<br/>
<img src="http://i.imgur.com/qS3JBYL.png" alt="" /></p>

<p>存储完之后编译，会出现这样的问题<br/>
<img src="http://i.imgur.com/D7akxGK.png" alt="" /><br/>
这是由于Visual Studio对于Unicode(UTF-8无签名)识别有误，我们一般在后面添加一些英文字符，或者“啊”等特殊的中文字符。</p>

<p>建议不要用这种解决方式</p>

<h3>解决方法二</h3>

<p>转码GBK->UTF-8<br/>
```
    <strong>String *cns = </strong>String::create(&ldquo;大家好啊&rdquo;);
    const char* nsc;</p>

<h1>if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)</h1>

<pre><code>std::string sns = MyUtility::gbk_2_utf8(ns-&gt;getCString());
cns = sns.c_str();
</code></pre>

<h1>else</h1>

<pre><code>cns = ns-&gt;getCString();
</code></pre>

<h1>endif</h1>

<pre><code>log("%s", cns);
auto label = LabelTTF::create(cns, "Arial", 24);
</code></pre>

<pre><code></code></pre>

<p>//在Win32平台下，将GBK编码转换为UTF-8
string MyUtility::gbk_2_utf8(const string text){</p>

<h1>if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) //条件编译</h1>

<pre><code>//这里面用的一些库只有win32平台才有的一些类库

//采用Lambda表达式，将string转换成wstring
wstring tes = [=](){
    setlocale(LC_ALL, "chs");
    const char* _Source = text.c_str();
    size_t _Dsize = text.size() + 1;
    wchar_t *_Dest = new wchar_t[_Dsize];
    mbstowcs(_Dest, _Source, _Dsize);
    std::wstring result = _Dest;
    delete[]_Dest;
    setlocale(LC_ALL, "C");
    return result;
}();

int asciSize = WideCharToMultiByte(CP_UTF8, 0, tes.c_str(), tes.size(), NULL, 0, NULL, NULL);
if(asciSize == ERROR_NO_UNICODE_TRANSLATION || asciSize==0){
    return string();
}

char *resultString = new char[asciSize];
int conveResult = WideCharToMultiByte(CP_UTF8, 0, tes.c_str(), tes.size(), resultString, asciSize, NULL, NULL);
if (conveResult != asciSize){
    return string();
}
string buffer = "";
buffer.append(resultString,asciSize);
delete[] resultString;
return buffer;
</code></pre>

<h1>else</h1>

<pre><code>return text;
</code></pre>

<h1>endif</h1>

<p>}</p>

<pre><code>
###解决方法三
其实还可以用文本文件来解决中文乱码，就是字符串从xml文件或者json中读取(注意，文本需要是UTF-8编码)，然后传值，这样不会出现乱码问题    


#使用标签
可以把标签理解为一个控件  

![](http://i.imgur.com/nDlGfb0.png)  

此处的大家好和中间的COCOS2DX图片就是标签  

一种是COCOS2DX这样的，可以叫美工做张图片然后放上去就可以了，静态的  
另外一种是"大家好"这样的动态文字  

##LabelTTF
TTF基于系统字库  

![](http://i.imgur.com/khRSKgT.png)  
</code></pre>

<p>//静态create函数创建
auto label = LabelTTF::create(&ldquo;大家好&rdquo;, &ldquo;Arial&rdquo;, 24);//如乱码请参照前面的解决
//在不同的平台中都是去找Arial这个系统库，然后去显示出来,24为字号</p>

<p>//指定标签的位置
label->setPosition(Vec2(origin.x + visibleSize.width/2,origin.y + visibleSize.height - label->getContentSize().height));
//记住设置位置和锚点，锚点没写就是默认的0.5,0.5
//把标签加入到层中
this->addChild(label, 1,123);//设置tag为123，方便后面获取
```</p>

<p>create函数的完整定义:
<code>   
/** creates a Label from a fontname, alignment, dimension in points and font size in points
     @since v2.0.1
*/
static LabelTTF * create(const std::string&amp; string, const std::string&amp; fontName, float fontSize,
                    const Size&amp; dimensions = Size::ZERO, TextHAlignment hAlignment = TextHAlignment::CENTER,
                    TextVAlignment vAlignment = TextVAlignment::TOP);
</code>
const std::string&amp; string   要显示的字符串<br/>
const std::string&amp; fontName   字体的名字<br/>
 float fontSize   字体的大小<br/>
const Size&amp; dimensions = Size::ZERO  尺寸-放在这个所定义的矩形的大小里面
TextHAlignment hAlignment = TextHAlignment::CENTER  水平方向的中心对齐<br/>
TextVAlignment vAlignment = TextVAlignment::TOP  垂直方向的顶对齐<br/>
后面三个参数可省略，都会有默认值</p>

<p>在cocos2d X3.01时，认为create已经过时了，但是这种用法还是能用,可能以后会去掉</p>

<h2>LabelAtlas</h2>

<p>基于图集的标签<br/>
<img src="http://i.imgur.com/3q7Fl2d.png" alt="" /></p>

<p>继承了：LabelProtocol-纯虚函数，相当于Java中的接口</p>

<p>显示的abcd的那些字母，放在一张图中了<br/>
<img src="http://i.imgur.com/UVGSL4n.png" alt="" /></p>

<pre><code class="C++ 创建并初始化标签">auto label1 = LabelAtlas::create("HelloWorld", "fonts/tuffy_bold_italic-charmap.png", 48, 66, ' ');
//(字符串，字体文件图集，宽，高，) 路径是 Resources/下  宽高不能随便设置！需要和图片对应的
label1-&gt;setPosition(Vec2(visibleSize.width / 2 - label1-&gt;getContentSize().width / 2, visibleSize.height - label1-getContentSize().height));
this-&gt;addChild(label1, 1);
</code></pre>

<h2>LabelBMFont</h2>

<p>位图字体标签，需要添加字体文件：包括一个图片集(.png)和一个字体坐标文件(.fnt)<br/>
LabelBMFont比LabelTTF快很多。LabelBMFont中的每个字符的宽度是可变的</p>

<p><img src="http://i.imgur.com/FHkqIqZ.png" alt="" /><br/>
.png很容易，叫美工做好图片就行<br/>
.fnt:<br/>
<img src="http://i.imgur.com/XtY5Ixb.png" alt="" /><br/>
这个就不是自己能手写出来的了~~ 那么我们就需要借助工具了<br/>
(大家可以简单的学习一下工具)</p>

<p>创建并初始化标签
```
    auto label2 = LabelBMFont::create(&ldquo;HelloWord&rdquo;,&ldquo;fonts/BMFont.fnt&rdquo;);
    label2->setPosition(Vec2(visibleSize.width / 2, visibleSize.height - label2->getContentSize().height));
    this->addChild(label2,1);</p>

<pre><code>效果：  
![](http://i.imgur.com/Sf2epLr.png)  

##Cocos2d-x 3.x标签类Label
Cocos2d-x 3.x后推出了新的标签类Label，这种标签通过使用FreeType(开源字体引擎)来使它在不同的平台上有相同的视觉效果。  
由于使用更快的缓存代理，它的渲染也将更加快速。Label还提供了描边和阴影等特效。  
![](http://i.imgur.com/HKQ3iDb.png)  

前面三个标签在3.0或者说3.1之后已经过时了，但是还可以用(不推荐使用了)。  
推荐使用该标签类Label，该类替换了前面的三个标签类  

创建Label类静态create函数常用的有如下几个：
</code></pre>

<p>static Label* createWithSystemFont(conststd::string &amp;text,   //是要显示的文字                           <br/>
const std::string&amp; font,                                     //系统字体名<br/>
float fontSize,                                             //字体的大小<br/>
const Size&amp; dimensions = Size::ZERO,                        //在屏幕上占用的区域大小,可省略<br/>
TextHAlignment  hAlignment = TextHAlignment::LEFT,          //文字横向对齐方式,可省略<br/>
TextVAlignment  vAlignment = TextVAlignment::TOP)           //文字纵向对齐方式,可省略<br/>
显示的是系统字体，指的是运行环境下的系统，而不是编译系统，相当于原来的LabelTTF</p>

<p>static Label* createWithTTF(conststd::string &amp; text,
const std::string &amp;  fontFile,                //字体文件<br/>
float fontSize,                                  //字体的大小<br/>
const Size &amp;  dimensions = Size::ZERO,                 //可省略<br/>
TextHAlignment          hAlignment = TextHAlignment::LEFT,    //可省略<br/>
TextVAlignment           vAlignment = TextVAlignment::TOP)      //可省略<br/>
createWithTTF和LabelTTF不一样了，也就是fontFile指定的不是系统字体，而是字体文件，也就是字体文件路径</p>

<p>static Label* createWithTTF(constTTFConfig&amp; ttfConfig, //配置参数 constTTFConfig-结构体
const std::string&amp; text,
TextHAlignment alignment = TextHAlignment::LEFT,
int maxLineWidth = 0)</p>

<p>static Label* createWithBMFont(conststd::string&amp; bmfontFilePath,      //位图字体文件<br/>
const std::string&amp;  text,                                         //是要显示的文字      <br/>
const TextHAlignment&amp; alignment = TextHAlignment::LEFT,          //可省略<br/>
int maxLineWidth = 0,                                              //可省略<br/>
const Point&amp;  imageOffset = Point::ZERO )                               //可省略</p>

<pre><code>
使用实例
</code></pre>

<pre><code>auto label1 = Label::createWithSystemFont("Hello World1", "Arial", 36);
label1-&gt;setPosition(Vec2(origin.x + visibleSize.width/2,
    origin.y + visibleSize.height - 100));
this-&gt;addChild(label1, 1);//Win32的字体库可以在控制面板中找到

auto label2 = Label::createWithTTF("Hello World2", "fonts/Marker Felt.ttf", 36);
label2-&gt;setPosition(Vec2(origin.x + visibleSize.width/2,
    origin.y + visibleSize.height - 200));
this-&gt;addChild(label2, 1);

auto label3 = Label::createWithBMFont("fonts/BMFont.fnt", "Hello World3");
label3-&gt;setPosition(Vec2(origin.x + visibleSize.width/2,
    origin.y + visibleSize.height - 300));
this-&gt;addChild(label3, 1);


TTFConfig ttfConfig("fonts/Marker Felt.ttf",
    36,
    GlyphCollection::DYNAMIC);
auto label4 = Label::createWithTTF(ttfConfig, "Hello World4");
label4-&gt;setPosition(Vec2(origin.x + visibleSize.width/2,
    origin.y + visibleSize.height - 400));
this-&gt;addChild(label4 , 1);

ttfConfig.outlineSize = 4;
auto label5 = Label::createWithTTF(ttfConfig, "Hello World5");
//ttfConfig-结构体配置，能配置更多的特效，比如描边，阴影，闪烁的文字等
//只能是TTF文件的，才能使用这些特效
label5-&gt;setPosition(Vec2(origin.x + visibleSize.width/2,
    origin.y + visibleSize.height - 500));
label5-&gt;enableShadow(Color4B(255,255,255,128), Size(4, -4));//设置阴影，阴影的颜色，阴影的大小 
label5-&gt;setColor(Color3B::RED);//设置颜色

this-&gt;addChild(label5, 1);
</code></pre>

<p>```</p>

<h2>标签中文乱码问题</h2>

<p>解决方法一:保存文件为Unicode(UTF-8无签名)<br/>
(不推荐使用)</p>

<p>解决方法二:写工具类，将字符串编码转换为UTF-8<br/>
参考前面的Win32平台下中文乱码问题 <br/>
<img src="http://i.imgur.com/fGs4T2L.png" alt="" /></p>

<h1>源代码下载地址：</h1>

<blockquote cite='陈浩翔'>
GITHUB源码下载地址:<strong>【<a href='https://github.com/chenhaoxiang/cocos2d-x/tree/master/20170627/code' target='_blank'>点我进行下载</a>】</strong></p>
</blockquote>


<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【Cocos2d-x】开发基础-Cocos2d-x坐标系]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/06/14/cocos2dx-coordinate-system/"/>
    <updated>2017-06-14T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/06/14/cocos2dx-coordinate-system</id>
    <content type="html"><![CDATA[<p>本篇博客讲解:<br/>
1.UI坐标<br/>
2.OpenGL坐标<br/>
3.世界坐标和模型坐标<br/>
4.实例：世界坐标转换为模型坐标<br/>
5.实例：模型坐标转换为世界坐标</p>

<!-- more -->


<hr />

<h1>UI坐标和OpenGL坐标</h1>

<p><img src="http://i.imgur.com/tXyhhzQ.png" alt="" /><br/>
UI坐标就是Android和iOS等应用开发的时候使用的二维坐标系。它的坐标原点是在左上角的。<br/>
UI坐标也叫视图坐标，它是和我们的OpenGL坐标是不一样的。OpenGL坐标是基于左下角的
<img src="http://i.imgur.com/698Z9ws.png" alt="" /> <br/>
OpenGL坐标是一种3D坐标，OpenGL是一个渲染的标准，渲染标准的坐标系是一种3D坐标系。<br/>
所以OpenGL主要是给3D世界来做渲染，但是cocos2d觉得OpenGL速度快，所以就把OpenGL拿过来了做为一个引擎，这样的话，cocos2d就使用OpenGL坐标作为默认坐标<br/>
OpenGL坐标在二维世界里，并没有什么太大的问题，不过就是Z轴基本不用。但是有时候也会用到，就是在绘制的顺序的时候，就需要Z轴了。</p>

<p>比如绘制两个精灵在一个位置，精灵之间会有遮挡的问题，这个就和z轴的绘制顺序有关了。</p>

<h2>从UI坐标到OpenGL坐标的转换</h2>

<p>其实就是左上角，左下角之间的转换。<br/>
屏幕的高度 - OpenGL坐标 = UI坐标<br/>
屏幕的高度 - UI坐标 = OpenGL坐标<br/>
<code>
Vec2 touchLocation = touch-&gt;getLocationInView(); //获取触摸点的位置，UI坐标系里的坐标
Vec2 touchLocation2 = Director::getInstance()-&gt;convertToGL(touchLocation);
</code>
touch是触摸点(Touch)对象</p>

<h2>右手坐标系和左手坐标系</h2>

<p><img src="http://i.imgur.com/kCbPAIl.png" alt="" /><br/>
在3D坐标系里，有两种坐标。一种是Z轴指向外面的坐标，一种是Z轴指向内部的坐标，如上图</p>

<p><img src="http://i.imgur.com/GQ9rtZL.png" alt="" /><br/>
指向外面的坐标称为右手坐标系<br/>
指向内部的坐标称为左手坐标系<br/>
大家用左右手演示一下就明白了。
注意大拇指指向X轴正方向，食指向上，中指弯曲<br/>
OpenGL属于右手坐标！<br/>
微软平台的Direct3D是左手坐标！<br/>
这两个是类似的技术</p>

<h1>世界坐标和模型坐标</h1>

<p>由于OpenGL坐标有可以分为：世界坐标和模型坐标，所以Cocos2d-x的坐标也有世界坐标和模型坐标。</p>

<p>举一个例子：<br/>
比如你去问路，可能有人会告诉你先向南走1000米，再向东走500米、<br/>
也可能会有人告诉你，先向右走1000米，再向左走500米、</p>

<p>世界坐标:<br/>
先向南走1000米，再向东走500米、也就是说以地球为参照物<br/>
模型坐标(也叫本地坐标):<br/>
先向右走1000米，再向左走500米、这里是以自身为参照物</p>

<p>所谓模型是什么，就是这个物体，这个精灵，也就是称为模型。<br/>
虽然cocos2d画的是2D对象，但是实际上是以3D技术来绘制的，因此还是叫模型坐标</p>

<p>世界坐标的整个坐标的参考系在第三方！也就是不是本身</p>

<p>比如：<br/>
<img src="http://i.imgur.com/5q7jsI6.png" alt="" /><br/>
看上图，坐标系上有ABC三个点，C是坐标原点，A参考C，B也参考C，那么，C的坐标就是A和B坐标的坐标系<br/>
所以我们把以C为参考的坐标(也就是以第三方为参考系的坐标)称为世界坐标<br/>
所以A的坐标是(5,5),B的坐标是(6,4)</p>

<p>采用A的模型坐标来描述B的位置:<br/>
我们也可以这么说，B相对于A的坐标是(1,-1),这样B就把A作为它的参考系，A就是模型坐标了！<br/>
也就是B在A这个模型坐标里所在的位置是(1,-1)</p>

<h2>世界坐标与模型坐标互相转换</h2>

<p>通过Node对象如下函数实现：<br/>
```C++ 世界坐标与模型坐标互相转换
Vec2 convertToNodeSpace ( const Vec2 &amp; worldPoint ) //将世界坐标转换为模型坐标。坐标原点看成模型(对象，精灵)的左下角所在
Vec2 convertToNodeSpaceAR ( const Vec2 &amp; worldPoint ) //将世界坐标转换为模型坐标。AR表示相对于锚点。</p>

<p>Vec2 convertTouchToNodeSpace ( Touch * touch ) //将世界坐标中触摸点转换为模型坐标。
Vec2 convertTouchToNodeSpaceAR ( Touch * touch ) //将世界坐标中触摸点转换为模型坐标。AR表示相对于锚点。
//凡是后面是ToNodeSpace的这个函数，是从世界坐标到模型坐标的转换  Node就是节点，也就是我们说的模型
//所有带有AR的，表示相对于锚点，也就是坐标原点看成模型(对象，精灵)的锚点所在</p>

<p>Vec2 convertToWorldSpace ( const Vec2 &amp; nodePoint ) //将模型坐标中触摸点转换为世界坐标。
Vec2 convertToWorldSpaceAR ( const Vec2 &amp; nodePoint ) //将模型坐标中触摸点转换为世界坐标。AR表示相对于锚点。
```</p>

<h1>实例：世界坐标转换为模型坐标</h1>

<p><img src="http://i.imgur.com/3yIjKwO.png" alt="" />  <br/>
Node1和Node2的像素是(300,100)<br/>
所以很容易得出:<br/>
A(100,400)<br/>
C(200,300)
C相对于A:(100,-100)</p>

<p>B(400,500)
C相对于B:(-200,-200)</p>

<p>Node2的世界坐标转换为相对于Node1的模型坐标:
```
//将Node2的位置转换为相对于Node1的模型坐标，不带AR的，表示相对于Node1的坐标原点,也就是A点
Vec2 point1 = node1->convertToNodeSpace(node2->getPosition());</p>

<p>//将Node2的位置转换为相对于Node1的模型坐标，不带AR的，表示相对于Node1的锚点,也就是B点
Vec2 point2 = node1->convertToNodeSpaceAR(node2->getPosition());
```</p>

<p>所以得出的结果就是:
```
log(&ldquo;Node2 NodeSpace = (%f,%f)&rdquo;,point1.x,point1.y);
//Node2 NodeSpace = (100.000000,-100.000000)</p>

<p>log(&ldquo;Node2 NodeSpaceAR = (%f,%f)&rdquo;, point2.x, point2.y);
//Node2 NodeSpaceAR = (-200.000000,-200.000000)
```</p>

<pre><code>bool HelloWorld::init()
{
    // 1. super init first
    if ( !Layer::init() )
    {
        return false;
    }

    auto node1 = Sprite::create("Node1.png");//Sprite是精灵
    node1-&gt;setPosition(Vec2(400,500));//设置位置
    node1-&gt;setAnchorPoint(Vec2(1.0, 1.0));//设置锚点

    this-&gt;addChild(node1,0);//层添加精灵

    auto node2 = Sprite::create("Node2.png");//Sprite是精灵
    node2-&gt;setPosition(Vec2(200, 300));//设置位置
    node2-&gt;setAnchorPoint(Vec2(0.5, 0.5));//设置锚点
    this-&gt;addChild(node2, 0);

    Vec2 point1 = node1-&gt;convertToNodeSpace(node2-&gt;getPosition());//将Node2的位置转换为相对于Node1的模型坐标，不带AR的，表示相对于Node1的坐标原点

    Vec2 point2 = node1-&gt;convertToNodeSpaceAR(node2-&gt;getPosition());

    log("Node2 NodeSpace = (%f,%f)",point1.x,point1.y);//Node2 NodeSpace = (100.000000,-100.000000)
    log("Node2 NodeSpaceAR = (%f,%f)", point2.x, point2.y);//Node2 NodeSpaceAR = (-200.000000,-200.000000)

    return true;
}
</code></pre>

<p><img src="http://i.imgur.com/IDhDV2w.png" alt="" /></p>

<h1>源代码下载地址：</h1>

<blockquote cite='陈浩翔'>
GITHUB源码下载地址:<strong>【<a href='https://github.com/chenhaoxiang/cocos2d-x/tree/master/20170614/code/OpenGLcoordinates' target='_blank'>点我进行下载</a>】</strong></p>
</blockquote>


<h1>实例：模型坐标转换为世界坐标</h1>

<p><img src="http://i.imgur.com/SOqOMNO.png" alt="" /></p>

<p>在游戏场景中有两个Node对象，其中Node1的坐标是(400,500),大小是300<em>100像素<br/>
Node2是放置在Node1中的，它对于Node1的模型坐标是(0,0),大小是150</em>150像素</p>

<p>Node2相对于Node1的模型坐标转换的世界坐标:<br/>
```
Vec2 point1 = node1->convertToWorldSpace(node2->getPosition());</p>

<blockquote><p>//node2->getPosition()为Node2在Node1中的模型坐标(相对于Node1的坐标原点得到的坐标) ->(convertToWorldSpace)->转换为世界坐标，Node2在Node1中的坐标实际上是(0,0),在世界坐标中，Node2的坐标其实就是A点的坐标
```
(150,50)为Node2的宽高<br/>
A点的坐标 = (400,500) - (150,50) = (250,450)</p></blockquote>

<p>上面的是没加上锚点的，如果加上锚点，是相对于锚点的坐标<br/>
加上锚点之后，Node1的锚点是B点，所以Node2相对于Node1的锚点的坐标是:</p>

<pre><code>Vec2 point2 = node1-&gt;convertToWorldSpaceAR(node2-&gt;getPosition());
&gt;//node2-&gt;getPosition()为Node2在Node1中的模型坐标(相对于再加上Node1的锚点的坐标得到的坐标) -&gt;(convertToWorldSpaceAR)-&gt;转换为世界坐标
</code></pre>

<p>Vec2 point2 得到的其实就是B点的坐标，也就是A点坐标，加上Node1锚点的坐标相对于A点的坐标。也就是(250,450)+(150,50) = (400,500)<br/>
也就是我们说的Node2的世界坐标！</p>

<pre><code>bool HelloWorld::init()
{
    // 1. super init first
    if (!Layer::init())
    {
        return false;
    }

    auto node1 = Sprite::create("Node1.png");//Sprite是精灵
    node1-&gt;setPosition(Vec2(400, 500));//设置位置
    node1-&gt;setAnchorPoint(Vec2(0.5, 0.5));//设置锚点

    this-&gt;addChild(node1, 0);//层添加精灵

    auto node2 = Sprite::create("Node2.png");//Sprite是精灵
    node2-&gt;setPosition(Vec2(0.0, 0.0));//设置位置
    node2-&gt;setAnchorPoint(Vec2(0.0, 0.0));//设置锚点
    node1-&gt;addChild(node2, 0);//把Node2放到Node1

    //将Node2的位置转换为相对于Node1的模型坐标，不带AR的，表示相对于Node1的坐标原点
    Vec2 point1 = node1-&gt;convertToWorldSpace(node2-&gt;getPosition());
    Vec2 point2 = node1-&gt;convertToWorldSpaceAR(node2-&gt;getPosition());

    log("Node2 WorldSpace = (%f,%f)", point1.x, point1.y);//Node2 WorldSpace = (250.000000,450.000000)
    log("Node2 WorldSpaceAR = (%f,%f)", point2.x, point2.y);//Node2 WorldSpaceAR = (400.000000,500.000000)

    return true;
}
</code></pre>

<pre><code class="C++ node1模型坐标来设置位置">node2-&gt;setPosition(Vec2(0.0, 0.0));//设置位置
node2-&gt;setAnchorPoint(Vec2(0.0, 0.0));//设置锚点
node1-&gt;addChild(node2, 0);//把Node2放到Node1
</code></pre>

<p>上面代码是使用node1模型坐标来设置位置的<br/>
也可以用世界坐标描述
<code>C++ 世界坐标描述
node2-&gt;setPosition(Vec2(250, 450));
node2-&gt;setAnchorPoint(Vec2(0.0, 0.0));
this-&gt;addChild(node2, 0);
</code></p>

<h1>源代码下载地址：</h1>

<blockquote cite='陈浩翔'>
GITHUB源码下载地址:<strong>【<a href='https://github.com/chenhaoxiang/cocos2d-x/tree/master/20170614/code/OpenGLcoordinates2' target='_blank'>点我进行下载</a>】</strong></p>
</blockquote>


<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【Cocos2d-x】开发基础-Node与Node层级架构]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/06/11/node-hierarchical-structure/"/>
    <updated>2017-06-11T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/06/11/node-hierarchical-structure</id>
    <content type="html"><![CDATA[<p>本篇博客讲解:<br/>
1.Node与Node层级架构<br/>
2.Node中重要的操作<br/>
3.Node中重要的属性<br/>
4.游戏循环与调度</p>

<!-- more -->


<hr />

<h1>Node与Node层级架构</h1>

<p>首先来看一张图<br/>
<img src="http://i.imgur.com/kGQ1oxN.png" alt="" /><br/>
这个图反应了Node与Node的层级架构<br/>
所谓层级架构其实就是树形结构/层次结构，从图上可以看出来，树的根是Scene(场景)，然后是层，层里面又包含了精灵，菜单，粒子系统，瓦片地图<br/>
所有这些元素，都有一个共同的父类，就是Node</p>

<p>这个树形结构，其实就是一种包含关系<br/>
<img src="http://i.imgur.com/wFK51kL.png" alt="" /><br/>
这2个文件共同定义了一个HelloWorld的层<br/>
class HelloWorld : public cocos2d::Layer<br/>
我们自己自定义了一个类HelloWorld继承了Layer，层最后要放到场景里去<br/>
<code>c++
Scene* HelloWorld::createScene()
{
    // 创建场景对象
    auto scene = Scene::create();
    // 创建层对象
    auto layer = HelloWorld::create();
    // 把层放到场景里
    scene-&gt;addChild(layer);
    // 返回这个场景
    return scene;
}
</code>
创建场景以及HelloWord这个层，然后把层放到场景里<br/>
通过addChild这个方法，把子节点加到父节点里面去<br/>
以此类推，可以把Layer添加到Scene里，也可以这样把精灵，菜单等添加到层里<br/>
<code>c++
this-&gt;addChild(menu, 1);//把菜单放到当前层
//把标签加入到层中
this-&gt;addChild(label, 1);
//把图片精灵加入到层中
this-&gt;addChild(sprite, 0);
</code>
代码在HelloWord.cpp中可以看到<br/>
所以，最开始的图上的层次结构，是通过add的这个方法添加上来的<br/>
既然有添加，那么就有移除方法，后面再介绍。<br/>
主要是树形结构，需要注意的就是添加的顺序和个数<br/>
一般来说，一个场景会有多个层，我们建立的HelloWord实例中，场景和层是一对一的关系<br/>
也就是场景中只放了一个层。实际上场景与层是一对多的关系<br/>
为了减少绘制的次数，不要建立太多的层，那样很消耗cpu</p>

<p>层与精灵也是一对多的关系，然后层与菜单，粒子系统，瓦片地图都是一对多的关系<br/>
菜单与菜单项是一对多的关系，一个菜单里会有多个菜单项<br/>
当cocos2d启动一个场景的时候，场景就会加载层，层会加载菜单等等，菜单会加载菜单项。就是这样一种树形结构</p>

<h1>Node中重要的操作</h1>

<p>由于场景、层、菜单、精灵&hellip;都是继承的Node，所以它们有一些共同的属性和方法</p>

<h2>创建节点</h2>

<pre><code class="c++ 创建节点">Node* childNode = Node::create()
</code></pre>

<h2>增加新的子节点</h2>

<pre><code class="c++ 增加新的子节点">node-&gt;addChild(childNode,0,123)
</code></pre>

<p>第一个参数是添加的节点；第二个参数是添加的Node的z轴的顺序(添加节点的时候会有顺序的，相当于绘制的时候的先后顺序)；第三个参数是Tag/标签，可以理解成id，通过这个tag来操作node对象    <br/>
<img src="http://i.imgur.com/eae63yS.png" alt="" /><br/>
附带第二个参数的英文介绍：<br/>
```
LocalZOrder is the &lsquo;key&rsquo; used to sort the node relative to its siblings.</p>

<p>The Node&rsquo;s parent will sort all its children based on the LocalZOrder value. If two nodes have the same LocalZOrder, then the node that was added first to the children&rsquo;s array will be in front of the other node in the array.</p>

<p>Also, the Scene Graph is traversed using the &ldquo;In-Order&rdquo; tree traversal algorithm ( <a href="http://en.wikipedia.org/wiki/Tree_traversal#In-order">http://en.wikipedia.org/wiki/Tree_traversal#In-order</a> ) And Nodes that have LocalZOrder values &lt; 0 are the &ldquo;left&rdquo; subtree While Nodes with LocalZOrder >=0 are the &ldquo;right&rdquo; subtree.
<code>
addChild有4个方法
</code>c++
virtual void addChild   ( Node * child)   <br/>
virtual void addChild   ( Node * child,int localZOrder)   <br/>
virtual void addChild   ( Node * child,int localZOrder,int tag)
virtual void addChild   ( Node * child,int localZOrder,const std::string &amp; name)  <br/>
```</p>

<h2>查找子节点</h2>

<pre><code class="c++ 通过Tag查找子节点">Node* node = node-&gt;getChildByTag(123)
</code></pre>

<h2>删除子节点</h2>

<pre><code class="c++ 删除子节点，并停止所有该节点上的一切动作">node-&gt;removeChildByTag(123,true)//第二个参数表示是否在内存中清除这个对象
</code></pre>

<pre><code class="c++ 通过Node指针删除节点">node-&gt;removeChild(childNode)//直接删除节点
</code></pre>

<pre><code class="c++ 删除所有子节点，并停止这些子节点上的一切动作">node-&gt;removeAllChildrenWithCleanup(true) //true-清除内存
</code></pre>

<pre><code class="c++ 从父节点Node中删除当前的节点对象，并停止所有该节点上的一切动作">node-&gt;removeFromParentAndCleanup(true) //true-清除内存
</code></pre>

<h1>Node中重要的属性</h1>

<p>Node两个非常重要的属性:<br/>
position和anchorPoint<br/>
position是指的位置，anchorPoint是指的锚点<br/>
位置(坐标)很好理解，就是比如放在(5,5),x=5,y=5.但是精灵图片是有大小的，这个时候就需要锚点了。  <br/>
我们用图来理解吧
1.anchorPoint为(0.5,0.5)，这个是默认值<br/>
<img src="http://i.imgur.com/P68puku.png" alt="" /><br/>
第一个参数0.5，是锚点距离左边边线的距离和图片整个的宽度的比例，也就是1/2<br/>
第二个参数0.5，是锚点距离底边高度和整个高度的比值，也就是1/2</p>

<p>2.anchorPoint为(0,0)，也就是精灵图片的左下角<br/>
<img src="http://i.imgur.com/DqOBDal.png" alt="" /></p>

<p>3.anchorPoint为(1.0,1.0)，也就是精灵图片的右上角  <br/>
<img src="http://i.imgur.com/hHux4IT.png" alt="" /></p>

<p>4.anchorPoint为(0.66,0.5)，这个具有普遍性<br/>
<img src="http://i.imgur.com/4ZzjNcC.png" alt="" /></p>

<h1>游戏循环与调度</h1>

<p>每一个游戏程序都有一个循环在不断运行，它是有导演对象来管理和维护。<br/>
如果需要场景中的精灵运动起来，我们可以在游戏循环中使用定时器（Scheduler）对精灵等对象的运行进行调度。<br/>
因为Node类封装了Scheduler类，所以我们也可以直接使用Node中调用函数。<br/>
Node中调用函数主要有：<br/>
```
void scheduleUpdate ( void )//开始游戏调度，每个Node对象只要调用该函数，那么这个Node对象就会定时地每帧回调用一次自己的update(float dt)函数，每帧调用一次update函数！这是固定的时间和函数<br/>
//下面这个函数更加个性化，可以自定义回调函数和时间
void schedule ( SEL_SCHEDULE selector,  float  interval )//与scheduleUpdate函数功能一样，不同的是我们可以指定回调函数（通过selector指定），也可以根据需要指定回调时间间隔
//一旦调度开始，就会不断循环</p>

<p>void unscheduleUpdate ( void )//停止update(float dt)函数调度  和scheduleUpdate对应
void unschedule ( SEL_SCHEDULE selector )//可以指定具体函数停止调度  和schedule对应</p>

<p>void unscheduleAllSelectors ( void )//可以停止所有调度
```</p>

<h1>源代码下载地址：</h1>

<blockquote cite='陈浩翔'>
GITHUB源码下载地址:<strong>【<a href='https://github.com/chenhaoxiang/cocos2d-x/tree/master/20170611/HelloWorld' target='_blank'>点我进行下载</a>】</strong></p>
</blockquote>


<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【Cocos2d-x】开发基础-Cocos2d-x核心概念]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/06/10/core-concept/"/>
    <updated>2017-06-10T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/06/10/core-concept</id>
    <content type="html"><![CDATA[<p>本篇博客讲解:<br/>
1.Cocos2d-x的核心概念</p>

<!-- more -->


<hr />

<h1>导演</h1>

<p>导演类Director(v3.0之前是CCDirector)用于管理场景对象。<br/>
(所以3.0版本和以前的最大区别(我们看到的最大区别)就是类前面的CC，3.0版本是把所以的类前缀CC都去掉了)</p>

<p>采用单例设计模式！(不多解释啦，不知道的朋友请搜索)
<code>c++ 获得导演类Director实例语句
auto director = Director::getInstance();//获取唯一的导演  单例模式
</code></p>

<h2>导演对象的职责/作用</h2>

<p>访问和改变场景<br/>
访问Cocos2d-x的配置信息<br/>
暂停、继续和停止游戏<br/>
转换坐标</p>

<p>上面只是导演对象的职责其中一部分，还有其他很多，但我们不需要让导演做很多事情(其他的事被隐藏了)，我们用的最多的应该就是访问和改变场景、暂停、继续和停止游戏和转换坐标</p>

<h1>场景</h1>

<p>场景类Scene(v3.0之前是CCScene)是构成游戏的界面，类似于电影中的场景。</p>

<p>像导演、场景、包括层，精灵等这些游戏的概念，其实都是从电影行业中过渡过来的。<br/>
那么，电影行业，我们知道有场景，有导演。<br/>
场景就是我们拍这场戏，我们布置的景  比如打斗的场景等<br/>
场景中会有男主角，女主角，那么男女主角就相当于我们这里的精灵了，包括道具什么的(精灵)，这些东西在一起，就构成了层</p>

<p>所以场景里面也会放一些层</p>

<h2>场景大致可以分为以下几类</h2>

<p>展示类场景。播放视频或简单的在图像上输出文字，来实现游戏的开场介绍、胜利和失败提示、帮助介绍<br/>
选项类场景。主菜单，设置游戏参数等(比如开始，暂停，继续菜单)<br/>
游戏场景。这是游戏的主要内容</p>

<p>Scene类图:继承图
<img src="http://i.imgur.com/2S6h9PZ.png" alt="" /></p>

<h1>层</h1>

<p>层是我们写游戏的重点，我们大约99%以上的时间是在层上实现我们游戏内容。<br/>
层的管理类似于Photoshop中的图层，它也是一层一层叠在一起</p>

<p>我们一般写的很多类都是层，然后在层上面添加精灵等.然后把层放到场景里<br/>
场景包含层，层包含精灵,菜单等对象</p>

<p>理论上来说，层的层数越多(层与层之间有覆盖的问题，后面的层会覆盖先绘制的层)，需要绘制的深度越深，越耗CPU<br/>
大家可以打开Photoshop，用里面的图层来理解，这样更加直观<br/>
<img src="http://i.imgur.com/4XUGFsE.png" alt="" /></p>

<h1>精灵</h1>

<p>精灵类Sprite(v3.0之前是CCSprite)是游戏中非常重要的概念，它包括了敌人、玩家控制的对象、静态物体、地图和背景等<br/>
通常情况它会进行运动，运动方式包括了：移动、旋转、放大、缩小和动画等</p>

<h1>菜单</h1>

<p>菜单在游戏中时非常重要的概念，它提供操作的集合，在Cococ2d-x中菜单类是Menu</p>

<p>Menu中包含菜单项<br/>
MenuItem，它有三个子类：<br/>
MenuItemLabel、MenuItemSprite和MenuItemToggle</p>

<p>之前的HelloWord中的关闭按钮其实就是一个菜单项<br/>
我们也可以用精灵来实现，但是菜单项封装了一些触摸事件，你不需要关心它事件处理的细节问题</p>

<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【Cocos2d-x】开发基础-第一个Cocos2d-x游戏]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/06/07/cocos2dx-hello/"/>
    <updated>2017-06-07T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/06/07/cocos2dx-hello</id>
    <content type="html"><![CDATA[<p>本篇博客讲解:<br/>
1.第一个Cocos2d-x游戏</p>

<!-- more -->


<hr />

<h1>第一个Cocos2d-x游戏</h1>

<h2>创建工程</h2>

<p>cocos工具：<br/>
就是这个，看图
<img src="http://i.imgur.com/WHlXrKy.png" alt="" />
命令工具cocos实现，cocos工具其实是cocos2d团队自己开发的。是使用Python脚本编写的，cocos工具的运行需要安装Python环境<br/>
(还会用到ant,eclipse等工具哦，后面介绍)<br/>
Python下载地址
<a href="https://www.python.org/">https://www.python.org/</a>
需要注意的是它目前有Python3和Python2可以下载，我们选择Python 2，不要下载3，因为2和3语法有很大差别，cocos这个工具是使用2编写的，如果你使用了3，会在脚本编译就出问题  <br/>
(我的源代码中有window的Python安装包)<br/>
下载->安装->配置环境变量(Path中添加Python根目录)<br/>
<img src="http://i.imgur.com/n5L6JbI.png" alt="" /></p>

<p>点击确定设置好。</p>

<p>因为你还没有设置其他环境变量，所以你需要到此目录下：<br/>
cocos2d-x-3.13.1\tools\cocos2d-console\bin<br/>
直接输入cmd回车
<img src="http://i.imgur.com/pMcZqEi.png" alt="" />
或者shift鼠标右键打开命令窗口，都行</p>

<p>如果你不知道怎么用，直接输入cocos会有帮助
<img src="http://i.imgur.com/r1BMr1e.png" alt="" /></p>

<p>终端中执行如下指令：</p>

<pre><code>cocos new -p com.uifuture -l cpp -d E://chxCocosWork HelloWord
</code></pre>

<p>com.uifuture是包名，最好是写上(可以不写)，因为在安卓发布打包需要<br/>
cpp是语言，表示生成c++语言，还有lua,js<br/>
E://chxCocosWork 为生成目录<br/>
HelloWord为工程名<br/>
<img src="http://i.imgur.com/atnBoCF.png" alt="" />
如果你生成过程有问题，或者无法找到cocos命令，有可能是你的Path没有加进去，或者你使用的Python版本是3.X。</p>

<p>也可以用这种写法
<code>
cocos new HelloWord -p
com.uifuture -l cpp -d E://chxCocosWork
</code></p>

<h2>工程文件结构</h2>

<p>生成的目录结构是这样的：
<img src="http://i.imgur.com/iK0PwUP.png" alt="" /></p>

<p>Resources文件夹是资源文件夹。<br/>
图片，声音，字体，字库等都在这个目录</p>

<p>Class目录是我们开发重点关注的文件夹，这里面都是cpp文件<br/>
其他的文件夹，基本都是和平台有关的</p>

<p>现在刚刚入门，我们不考虑平台移植的问题，现在只关心Class目录中文件的编写</p>

<p>打开目录proj.win32，使用VS打开项目。 (使用VS打开HelloWorld.sln即可)<br/>
<img src="http://i.imgur.com/8hfsLDh.png" alt="" /></p>

<p>还有一些其他的工程：
<img src="http://i.imgur.com/p4cogHU.png" alt="" /></p>

<p>也就是说，HelloWord这个工程需要运行，需要依赖这些工程！<br/>
libcocos2d就是所有cocos2d的源码都是放在这个工程里面的，这个是和项目根目录cocos2d这个文件夹对应的</p>

<p>运行工程：(第一次编译可能需要较长时间)
<img src="http://i.imgur.com/pmlDOeB.png" alt="" /></p>

<p>左下角的一些数字，就是输出的帧;GL vwets就是绘制图形需要的顶点;GL calls 就是绘制的精灵的个数。右下角的按钮是菜单，你可以选择退出游戏</p>

<h2>代码解释</h2>

<p>我们看HelloWordScene.h<br/>
```c++ HelloWordScene.h</p>

<h1>ifndef <strong>HELLOWORLD_SCENE_H</strong></h1>

<h1>define <strong>HELLOWORLD_SCENE_H</strong></h1>

<h1>include &ldquo;cocos2d.h&rdquo;</h1>

<p>class HelloWorld : public cocos2d::Layer
{
public:
    static cocos2d::Scene* createScene();</p>

<pre><code>virtual bool init();

// a selector callback
void menuCloseCallback(cocos2d::Ref* pSender);

// implement the "static create()" method manually
CREATE_FUNC(HelloWorld);
</code></pre>

<p>};</p>

<h1>endif // <strong>HELLOWORLD_SCENE_H</strong></h1>

<pre><code>里面定义了一个类HelloWorld,继承了cocos2d::Layer(层)  
虽然文件名叫HelloWordScene,Scene是场景，但是实际上里面的类是HelloWorld，实际上是层  
创建层的同时会先创建层所在的场景，层是要放在场景里面的。  

AppDelegate是一个应用程序委托对象，如果懂ios开发的，应该会对这个比较熟悉。  
它的作用就是，应用程序启动的时候会调用它。
</code></pre>

<h1>ifndef  <em>APP_DELEGATE_H</em></h1>

<h1>define  <em>APP_DELEGATE_H</em></h1>

<h1>include &ldquo;cocos2d.h&rdquo;</h1>

<p>/**
@brief    The cocos2d Application.</p>

<p>Private inheritance here hides part of interface from Director.
*/
class  AppDelegate : private cocos2d::Application
{
public:
    AppDelegate();
    virtual ~AppDelegate();</p>

<pre><code>virtual void initGLContextAttrs();

/**
@brief    Implement Director and Scene init code here.
@return true    Initialize success, app continue.
@return false   Initialize failed, app terminate.
*/
virtual bool applicationDidFinishLaunching();

/**
@brief  Called when the application moves to the background
@param  the pointer of the application
*/
virtual void applicationDidEnterBackground();

/**
@brief  Called when the application reenters the foreground
@param  the pointer of the application
*/
virtual void applicationWillEnterForeground();
</code></pre>

<p>};</p>

<h1>endif // <em>APP_DELEGATE_H</em></h1>

<pre><code>applicationDidFinishLaunching 这个函数是在程序启动的时候会调用它，也就是在游戏启动的时候调用，一般进行游戏的初始化，比如游戏的导演啊，场景啊等在这里进行初始化。  
applicationDidEnterBackground 是退到后台，就是点击home键，回到桌面。接电话或者跳到另一个应用程序去，都会调用这个函数。  
applicationWillEnterForeground 是从后台重新回到前台，也就是从手机任务栏重新回到游戏，会调用这个函数   
以上三个函数是和游戏的生命周期有关系的。  
HelloWorldScene.cpp
</code></pre>

<h1>include &ldquo;HelloWorldScene.h&rdquo;</h1>

<h1>include &ldquo;SimpleAudioEngine.h&rdquo;</h1>

<p>USING_NS_CC;</p>

<p>Scene* HelloWorld::createScene()
{
    // 创建场景对象
    auto scene = Scene::create();</p>

<pre><code>// 创建层对象
auto layer = HelloWorld::create();

// 把层放到场景里
scene-&gt;addChild(layer);

// 返回这个场景
return scene;
</code></pre>

<p>}</p>

<p>// on &ldquo;init&rdquo; you need to initialize your instance
// 初始化当前这个层
bool HelloWorld::init()
{
    //////////////////////////////
    // 1. super init first
    if ( !Layer::init() )
    {
        return false;
    }</p>

<pre><code>auto visibleSize = Director::getInstance()-&gt;getVisibleSize();//得到屏幕的大小(可见区域大小)
Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin();//得到可见区域大小的左下角坐标

/////////////////////////////
// 2. add a menu item with "X" image, which is clicked to quit the program
//    you may modify it.

// add a "close" icon to exit the progress. it's an autorelease object
// 得到图片菜单 以及设置回调函数
auto closeItem = MenuItemImage::create(
                                       "CloseNormal.png",
                                       "CloseSelected.png",
                                       CC_CALLBACK_1(HelloWorld::menuCloseCallback, this));
//关闭的按钮 
closeItem-&gt;setPosition(Vec2(origin.x + visibleSize.width - closeItem-&gt;getContentSize().width/2 ,
                            origin.y + closeItem-&gt;getContentSize().height/2));

// create menu, it's an autorelease object
//把菜单项放到菜单里
auto menu = Menu::create(closeItem, NULL);
//指定菜单的位置 设置显示的坐标位置
menu-&gt;setPosition(Vec2::ZERO);
this-&gt;addChild(menu, 1);//把菜单放到当前层

/////////////////////////////
// 3. add your codes below...

//标签 也就是中间显示的那个文字  以及加载字体
auto label = Label::createWithTTF("Hello World", "fonts/Marker Felt.ttf", 24);

//指定标签的位置
label-&gt;setPosition(Vec2(origin.x + visibleSize.width/2,
                        origin.y + visibleSize.height - label-&gt;getContentSize().height));

//把标签加入到层中
this-&gt;addChild(label, 1);

//指定一个图片的精灵
auto sprite = Sprite::create("HelloWorld.png");

// 设置图片精灵的位置
sprite-&gt;setPosition(Vec2(visibleSize.width/2 + origin.x, visibleSize.height/2 + origin.y));

//把图片精灵加入到层中
this-&gt;addChild(sprite, 0);

return true;
</code></pre>

<p>}</p>

<p>//点击close菜单项来回调的
void HelloWorld::menuCloseCallback(Ref* pSender)
{
    //Close the cocos2d-x game scene and quit the application
    Director::getInstance()->end();</p>

<pre><code>//条件编译 ，也就是满足条件就编译过去，如果不满足，就相当于注释了
</code></pre>

<h1>if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS)</h1>

<pre><code>exit(0);
</code></pre>

<h1>endif</h1>

<pre><code>/*To navigate back to native iOS screen(if present) without quitting the application  ,do not use Director::getInstance()-&gt;end() and exit(0) as given above,instead trigger a custom event created in RootViewController.mm as below*/

//EventCustom customEndEvent("game_scene_close_event");
//_eventDispatcher-&gt;dispatchEvent(&amp;customEndEvent);
</code></pre>

<p>}
```</p>

<p>这样我们就得到一个能执行的HelloWord程序啦</p>

<p>因为cocos2dx项目工程太大，只上传Classes一些cpp文件啦，你可以手动把代码加入到你的cocos2dx项目工程中。</p>

<h1>源代码下载地址：</h1>

<blockquote cite='陈浩翔'>
GITHUB源码下载地址:<strong>【<a href='https://github.com/chenhaoxiang/cocos2d-x/tree/master/20170607/HelloWorld' target='_blank'>点我进行下载</a>】</strong></p>
</blockquote>


<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
</feed>
