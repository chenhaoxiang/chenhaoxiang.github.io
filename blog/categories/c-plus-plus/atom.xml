<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C-plus-plus | 谙忆-人生之旅]]></title>
  <link href="http://chenhaoxiang.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://chenhaoxiang.github.io/"/>
  <updated>2017-08-22T23:51:28+08:00</updated>
  <id>http://chenhaoxiang.github.io/</id>
  <author>
    <name><![CDATA[陈浩翔]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【C++】C++友元]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/06/20/c-plus-plus-friendFunction/"/>
    <updated>2017-06-20T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/06/20/c-plus-plus-friendFunction</id>
    <content type="html"><![CDATA[<p>C++中可以使用friend关键字来将函数、类声明为某个类的友元<br/>
友元包括友元函数和友元类<br/>
友元具有一些特权，可以访问private的成员<br/>
友元只能授予，不能索取，单向，不能传递(比如a是b的友元，b是c的友元，但a不是c的友元)</p>

<!-- more -->


<hr />

<h1>友元函数</h1>

<p>在类体中使用friend关键字对友元函数进行声明：<br/>
将非成员函数/一般函数声明为友元：<br/>
friend void func();  //func为非成员函数，不属于任何类<br/>
将其他类的成员函数声明为友元：<br/>
friend void CTime::getNum();//getNum为CTime类的成员。</p>

<h1>友元类</h1>

<p>在类体中使用friend关键字将某类声明为自己的友元类。<br/>
friend CTime;</p>

<p>好处就是方便，可以在其他类或方法直接访问私有成员</p>

<p>缺点：<br/>
面向对象的基本原则包括封装性和信息隐藏，而由于友元可以访问其他类的私有成员，这是对封装原则的一个破坏。因此使用友元的时候要特别慎重。</p>

<h1>实例</h1>

<pre><code class="C++ Time.h">#ifndef TIME_H
#define TIME_H 
#include "Date.h"
class CTime
{
public:
    CTime();
    CTime(int hour, int minute, int second = 0);
    CTime(int value);
    CTime(CTime&amp; time);
    ~CTime();
    void setHour(int hour);
    void setMinute(int minute);
    void setSecond(int second);

    int getHour();
    int getMinute();
    int getSecond(); 

    int getNum() const;

    //friend CDate;//声明友元类,需要声明class CDate;    这样整个类都可以访问CTime的私有成员的了,由于我们只在disPlay函数中访问，所以可以用下面的方法
    friend void CDate::disPlay(const CTime&amp; time);
    friend void func();//告诉编译器，CTime这个类，已经将func()这个函数声明为自己的友元函数，这个声明可以放在本CTime类中任何地方
private:
    int m_nHour;
    int m_nMinute;
    int m_nSecond;
    const int m_nNum;
};

#endif
</code></pre>

<pre><code class="C++ Date.h">#ifndef DATA_H
#define DATA_H

class CTime;//类的前置声明，一般情况下，是需要声明之后才可以使用的

class CDate
{
public:
    CDate(int year, int month, int day);

    //friend CTime;//在这里声明友元没用，因为友元只能授予，不能索取！
    void disPlay(const CTime&amp; time);//使用的是类的引用(引用也是使用指针来实现的),这里不声明是可以的

private:
    int m_nYear;
    int m_nMonth;
    int m_nDay;

};
#endif
</code></pre>

<p>main.cpp
<figure class='code'><figcaption><span>main.cpp</p></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='C++'><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span><span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span><span class="s">&quot;Time.h&quot;</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Date</span><span class="p">.</span><span class="n">h</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">func</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CTime</span> <span class="n">time</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="n">time</span><span class="p">.</span><span class="n">m_nHour</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">time</span><span class="p">.</span><span class="n">m_nHour</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">CTime</span> <span class="n">time</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CTime</span> <span class="k">const</span> <span class="n">time2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">time</span><span class="p">.</span><span class="n">getNum</span><span class="p">()</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">func</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">CDate</span> <span class="n">date</span><span class="p">(</span><span class="mi">2015</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">26</span><span class="p">);</span>
</span><span class='line'><span class="n">date</span><span class="p">.</span><span class="n">disPlay</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">getchar</span><span class="p">();</span>
</span><span class='line'><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>演示结果</h2>

<p><img src="http://i.imgur.com/3zb3loZ.png" alt="" /></p>

<h1>源代码下载地址：</h1>

<blockquote cite='陈浩翔'>
GITHUB源码下载地址:<strong>【<a href='https://github.com/chenhaoxiang/C-Study/tree/master/20170620/code/friendFunction' target='_blank'>点我进行下载</a>】</strong></p>
</blockquote>


<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【C++】const对象和const成员]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/06/03/const-object-member/"/>
    <updated>2017-06-03T21:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/06/03/const-object-member</id>
    <content type="html"><![CDATA[<p>如果我们在定义一个对象之后，不希望在后面对这个对象进行修改，那么我们可以把这个对象声明为const对象。<br/>
声明为const对象之后，这个对象的所有数据成员后面都不能被修改！</p>

<!-- more -->


<hr />

<h1>const对象</h1>

<p>定义类对象时可以将其指定为const对象。定义后const对象不能再被修改。<br/>
const对象不能调用非const类型的成员函数。<br/>
有两种方法来定义一个const对象：
const 类名 对象名<br/>
类名 const 对象名<br/>
这两种方法是等价的。</p>

<p>如果一个对象被定义成const对象，那么它就不能调用这个类中的非const成员函数。<br/>
const对象调用的成员函数一定都得是const！</p>

<pre><code class="c++ 定义const对象">//const
const CTime time4(10);
CTime const time5;
</code></pre>

<p>如果你用const对象引用了这个类中的非const成员函数，就会报错:
<code>
错误  1   error C2662: “int CTime::getHour(void)”: 不能将“this”指针从“const CTime”转换为“CTime &amp;”
e:\chenhaoxiang\20170603\test2\test2\mian.cpp   34  1   test2
</code>
其实就是告诉我们const对象不能引用非const成员函数<br/>
为什么要有这个规则:<br/>
因为在非const成员函数内部可能对对象进行修改，比如set函数<br/>
这个规则也就是强制用户不要对const成员进行错误的修改</p>

<h1>const成员</h1>

<h2>1.const数据成员</h2>

<p>也就是变量，比如实例中的m_hour，m_minute是普通数据成员</p>

<p>在类内部使用const关键字来声明const数据成员。const数据成员的值不能被修改。<br/>
初始化时比较特殊，只能通过初始化列表初始化。不能在构造函数里赋值。</p>

<h2>2.初始化列表</h2>

<p>初始化列表：<br/>
除了在构造函数中对数据成员进行初始化，C++还提供另外一种方法来对数据成员进行初始化<br/>
初始化列表并不是在构造函数内进行初始化<br/>
构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。
<code>
const int num;
</code>
必须初始化，而且不能在构造函数中初始化！<br/>
<figure class='code'><figcaption><span>main.cpp</p></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='C++'><span class='line'><span class="n">CTime</span><span class="o">::</span><span class="n">CTime</span><span class="p">()</span> <span class="o">:</span> <span class="n">num</span><span class="p">(</span><span class="mi">10</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">m_hour</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">m_minute</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">m_second</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">m_nNum</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'><span class="n">cout</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">m_nNum</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span><span class='line'><span class="n">CTime</span><span class="o">::</span><span class="n">CTime</span><span class="p">(</span><span class="kt">int</span> <span class="n">hour</span><span class="p">)</span> <span class="o">:</span> <span class="n">num</span><span class="p">(</span><span class="mi">10</span><span class="p">){</span>
</span><span class='line'>    <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_hour</span> <span class="o">=</span> <span class="n">hour</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//(*this).m_hour = hour; //效果一样的</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//复制构造函数</span>
</span><span class='line'><span class="n">CTime</span><span class="o">::</span><span class="n">CTime</span><span class="p">(</span><span class="n">CTime</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">time</span><span class="p">)</span> <span class="o">:</span> <span class="n">num</span><span class="p">(</span><span class="mi">10</span><span class="p">){</span>
</span><span class='line'>    <span class="n">m_hour</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">m_hour</span><span class="p">;</span>
</span><span class='line'>    <span class="n">m_minute</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">m_minute</span><span class="p">;</span>
</span><span class='line'>    <span class="n">m_second</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">m_second</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//cout &amp;lt;&amp;lt; &amp;ldquo;进入复制构造函数&amp;rdquo; &amp;lt;&amp;lt; endl;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="err">每一个构造函数都需要初始化这个</span><span class="k">const</span><span class="err">成员，而且复制构造函数也需要初始化</span><span class="n">num</span><span class="err">，因为复制构造函数也是一种构造函数！</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">##3.const成员函数</span>
</span><span class='line'><span class="k">const</span><span class="err">成员函数只能被</span><span class="k">const</span><span class="err">对象引用。</span><span class="k">const</span><span class="err">成员函数内可以引用</span><span class="k">const</span><span class="err">数据成员，也可以引用非</span><span class="k">const</span><span class="err">数据成员，但不能修改非</span><span class="k">const</span><span class="err">数据成员的值。但不能调用非</span><span class="k">const</span><span class="err">成员函数。</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">getNum</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="err">对于</span><span class="k">const</span><span class="err">函数的外部定义，也需要写</span><span class="k">const</span><span class="err">限定符</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">c</span><span class="o">++</span> <span class="err">实现</span>
</span><span class='line'><span class="kt">int</span> <span class="n">CTime</span><span class="o">::</span><span class="n">getNum</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">const</span><span class="err">成员函数存在的意义在于它能被</span><span class="k">const</span><span class="err">常对象调用</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">c</span><span class="o">++</span> <span class="err">调用</span>
</span><span class='line'><span class="n">CTime</span> <span class="k">const</span> <span class="n">time5</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">time5</span><span class="p">.</span><span class="n">getNum</span><span class="p">()</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">endl</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
 如果在const成员函数的定义中出现了任何修改对象成员数据的现象，都会在编译时被检查出来</p>

<p>如果我们是真的想在const成员函数中修改值呢，比如我需要m_age++;<br/>
比如下面定义了一个m_age 类成员：
<code>
int m_age;
</code>
<code>
int CTime::getNum() const {
    if (m_age == 0){
        m_age++;
    }
    else{
        m_age = 0;
    }
    return num;
}
</code>
假如我们不做其他事情，这样的写法，在编译时是无法通过的。</p>

<p>有些时候，我们想要让const函数具有修改某个成员数据值的能力。<br/>
比如一些内部的状态量，对外部用户无所谓，但是对整个对象的运行却大有用处,如支持缓存的技术。<br/>
遇到这种问题，我们可以把一个成员数据定义为mutable（多变的），它表示这个成员变量可以被const成员函数修改却不违法。<br/>
比如下面定义了这样一个m_age 类成员：
<code>
mutable int m_age;
</code>
<code>
int CTime::getNum() const {
    if (m_age == 0){
        m_age++;
    }
    else{
        m_age = 0;
    }
    return num;
}
</code>
这样，即使像getNum()这样的const成员函数修改它也是合法的。<br/>
但需要注意的时，不要滥用mutabe描述符，如果在某个类中只有少数一部分是被允许const常量函数修改的，使用mutable是再合适不过的。如果大部分数据都定义为mutable，那么最好将这些需要修改的数据放入另一个独立的对象里，并间接地访问它。</p>

<h1>源代码下载地址：</h1>

<blockquote cite='陈浩翔'>
GITHUB源码下载地址:<strong>【<a href='https://github.com/chenhaoxiang/C-Study/tree/master/20170603/test2' target='_blank'>点我进行下载</a>】</strong></p>
</blockquote>


<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【C++】C++类的静态成员]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/06/03/static-member/"/>
    <updated>2017-06-03T18:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/06/03/static-member</id>
    <content type="html"><![CDATA[<p>类的静态成员包括静态的数据成员和静态的成员函数！<br/>
static关键字</p>

<!-- more -->


<hr />

<h1>静态数据成员</h1>

<p>比如我们现在要设计一款战争游戏，在这款游戏中，分为多个兵种，每个兵种都有一定数量的士兵，游戏过程中，每隔一定时间每个兵种都会产生一定数量的士兵，由于战争的消耗，每个兵种的士兵都会减少。<br/>
为了使情节更逼真，引入了士气这个概念，当士气比较高的时候，这个兵种的战斗力就比较强，士气低的时候，这个兵种的战斗力就比较弱。<br/>
士兵的士气受很多因素影响，其中一个最直接的因素就是和这个兵种的数量直接相关，当这个兵种的士兵比较多，这个兵种的士气就比较高，战斗力就比较强。如果说当前的兵种士兵比较少，那么士气就比较弱，战斗力也比较弱。</p>

<p>为了实现这种情况，那么我们就记录当前士兵的数量这个变量。
一种比较简单的方法就是，我们可以维护一组全局的变量，每个全局变量都会记录某个兵种当前的数量。<br/>
但是使用全局变量会引入比较多的问题，不推荐使用！<br/>
1.使用全局变量的时候，安全性无法得到保证。因为我们在程序的各个地方都可以修改全局变量的值。</p>

<p>2.全局变量也会导致命名空间的污染，如果我们的程序比较大，如果定义了多个全局变量，那么各个模块就可能会冲突！</p>

<p>另一种方法就是使用静态数据成员，因为静态数据成员是各个对象所共有的，不属于某个具体的对象。</p>

<p>静态数据成员为各个对象共有，不属于某个具体的对象，所有对象都可以对它进行引用，都可以读取和修改。若一个对象修改了该静态成员的值，则在其他各个对象中该数据成员的值都会同时改变。</p>

<p>定义静态数据成员 以static关键字开头。
<code>c++ 定义静态数据成员
static int m_nNum;
</code>
定义之后不要忘记在cpp中初始化这个静态成员变量。(初始化的时候不要加static关键字哦)
否则在编译时就会报错：
<code>
错误  1   error LNK2001: 无法解析的外部符号 "private: static int CTime::m_nNum" (?m_nNum@CTime@@0HA) E:\chenhaoxiang\20170603\test2\test2\Time.obj   test2
</code></p>

<p>静态的数据成员是属于这个类的，而不是对象！<br/>
定义类时就为静态数据成员分配空间，不随对象的建立而分配空间。<br/>
static的成员变量不能在类内进行初始化！<br/>
定义完类之后就可以直接引用/访问，<br/>
引用方法： <br/>
1.类名::静态成员<br/>
2.对象名.静态成员<br/>
在类内的静态数据成员仅仅是对该成员的声明，同时还需要在类外部进行定义。</p>

<h1>静态成员函数</h1>

<p>在声明成员函数时在函数前添加static关键字就定义了静态成员函数。<br/>
<code>C++ 声明
static int getNum();
</code>
<code>c++ 定义
int CTime::getNum(){
    return m_nNum;
}
</code>
与静态数据成员一样，静态成员函数也是类的一部分。两种引用的方法。</p>

<pre><code class="C++ 调用的两种方法">CTime::getNum();
time.getNum();
</code></pre>

<p>静态成员函数一般是为了处理静态的数据成员。<br/>
与一般成员函数的区别：非静态成员函数有this指针，静态成员函数没有this指针。<br/>
因为它可以在未定义类对象时就可以引用。因此静态成员函数不能访问本类中的非静态成员。（包括成员函数和数据成员）。</p>

<p>比如在前面定义的getNum()静态函数中，是无法调用其他的非静态方法和变量的！<br/>
因为getNum()是依赖于具体的类，而其他非静态成员是依赖于具体对象的！<br/>
getNum()不依赖于任何对象！</p>

<p>类中定义的静态数据成员可以代替全局变量，而且没有全局变量的缺点，作用域仅限于当前类的作用域，防止了在其他类修改成员！</p>

<h1>源代码下载地址：</h1>

<blockquote cite='陈浩翔'>
GITHUB源码下载地址:<strong>【<a href='https://github.com/chenhaoxiang/C-Study/tree/master/20170603/test2' target='_blank'>点我进行下载</a>】</strong></p>
</blockquote>


<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【C++】This指针和复制构造函数]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/06/03/this-pointer/"/>
    <updated>2017-06-03T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/06/03/this-pointer</id>
    <content type="html"><![CDATA[<p>在声明一个类的时候，是没有分配存储空间的，只有在真正定义一个对象的时候，程序才会为这个对象分配相应的存储空间。<br/>
如果定义了多个对象，这些对象都有自己的存储空间，但是这些对象都是用相同的成员方法的。</p>

<p>当不同的对象调用成员方法时，怎么保证就是这个对象的成员？</p>

<!-- more -->


<hr />

<h1>this指针</h1>

<p>在每个成员函数中，都包含一个特殊的指针。<br/>
这个指针的名字是固定的，就是this指针。<br/>
this指针是指向类对象的指针，它的值是当前被调用的所在对象的地址！</p>

<p>this指针是指向本类对象的指针，它作为参数传递给成员函数<br/>
this指针是隐式使用的。由编译器自动实现，我们不必人为的在形参中添加this指针。</p>

<p>因为this表示这个对象的指针，所以*this就表示这个对象了</p>

<p>(<em>this).调用成员变量/函数和this->调用成员变量/函数,是一样的效果！<br/>
注意给</em>this添加括号，因为.运算符的优先级比较高</p>

<h1>复制构造函数</h1>

<p>复制构造函数和普通构造函数有一些相似处的，也没有返回值，类名作为函数名！</p>

<p>复制构造函数一种特殊的构造函数，在创建一个新的对象时将其他对象作为参数时，<br/>
编译器将会调用复制构造函数。不提供时使用默认构造函数。默认构造函数内部各个成员变量赋值。<br/>
创建之后，新对象是老对象的副本，二者值相同。但具有不同的存储空间。<br/>
<code>C++ 形式
CTime(CTime&amp; time);//使用类名对象作为参数，传引用
</code></p>

<h2>调用复制构造函数的时机：</h2>

<p>在什么情况下使用复制构造函数</p>

<h3>1.以其他对象作为参数创建新对象时。</h3>

<p>比如:创建一个新的对象的时候，把原来的一个对象作为参数传递给新的对象作为构造函数<br/>
<code>
CTime time;
CTime time2(time);//会自动执行复制构造函数，复制成员等  
</code><br/>
<code>c++ 复制构造函数
CTime::CTime(CTime&amp; time){
    m_hour = time.m_hour;
    m_minute = time.m_minute;
    m_second = time.m_second;
}
</code></p>

<pre><code class="c++ 通过复制构造函数复制原来的time">    CTime time;
    time.setHour(10);//通过成员方法设置值
    time.setMinute(20);
    time.setSecond(30);

    cout &lt;&lt; time.getHour() &lt;&lt; ":" &lt;&lt; time.getMinute() &lt;&lt; ":" &lt;&lt; time.getSecond() &lt;&lt; endl;
    //输出结果： 10:20:30

    CTime time2(time);

    cout &lt;&lt; time2.getHour() &lt;&lt; ":" &lt;&lt; time2.getMinute() &lt;&lt; ":" &lt;&lt; time2.getSecond() &lt;&lt; endl;
</code></pre>

<p>(注意，构造函数实现的时候，需要在其他函数前面先实现)<br/>
复制构造函数也是构造函数的一种！</p>

<h3>2.类对象（传值）作为函数参数时。</h3>

<pre><code class="C++ 类对象（传值）作为函数参数时。">#include &lt;iostream&gt;
#include "Time.h"
using namespace std;

void func(CTime time){
    cout &lt;&lt; time.getHour()&lt;&lt;endl;
}

int main(){
    CTime time;
    time.setHour(10);//通过成员方法设置值
    time.setMinute(20);
    time.setSecond(30);
    CTime time2(time);//第一次调用复制构造函数

    func(time);//第二次调用复制构造函数  复制给func中的形参time

    cout &lt;&lt; time.getHour() &lt;&lt; ":" &lt;&lt; time.getMinute() &lt;&lt; ":" &lt;&lt; time.getSecond() &lt;&lt; endl;
    //输出结果： 10:20:30

    cout &lt;&lt; time2.getHour() &lt;&lt; ":" &lt;&lt; time2.getMinute() &lt;&lt; ":" &lt;&lt; time2.getSecond() &lt;&lt; endl;

    getchar();//这句是为了防止输出窗口秒关闭
    return 0;
}
</code></pre>

<h3>3.类对象作为函数返回值时。</h3>

<pre><code class="C++ 类对象作为函数返回值时。">#include &lt;iostream&gt;
#include "Time.h"
using namespace std;

void func(CTime time){
    cout &lt;&lt; time.getHour()&lt;&lt;endl;
}
CTime func1(CTime time){
    //复制给func1中的形参time 也会调用一次复制构造函数
    cout &lt;&lt; time.getHour() &lt;&lt; endl;
    return time;//time在返回的时候会复制给返回的值，这个时候会调用复制构造函数
}


int main(){
    CTime time;
    time.setHour(10);//通过成员方法设置值
    time.setMinute(20);
    time.setSecond(30);
    CTime time2(time);//第一次调用复制构造函数

    func(time);//第二次调用复制构造函数  复制给func中的形参time

    CTime time3 = func1(time);//第三次和第四次调用复制构造函数

    cout &lt;&lt; time.getHour() &lt;&lt; ":" &lt;&lt; time.getMinute() &lt;&lt; ":" &lt;&lt; time.getSecond() &lt;&lt; endl;
    //输出结果： 10:20:30


    cout &lt;&lt; time2.getHour() &lt;&lt; ":" &lt;&lt; time2.getMinute() &lt;&lt; ":" &lt;&lt; time2.getSecond() &lt;&lt; endl;

    getchar();//这句是为了防止输出窗口秒关闭
    return 0;
}
</code></pre>

<p>上面就是复制构造函数使用的三种情形！</p>

<p>如果我们把复制构造函数 CTime::CTime(CTime&amp; time)修改为CTime::CTime(CTime time) <br/>
CTime&amp; time是一个引用类型的参数，现在将引用去掉的话，就满足了调用复制构造函数中的一种，以类对象（传值）作为函数参数时，<br/>
这样在使用的时候，就会造成死循环！</p>

<p>所以注意复制构造函数是传引用来实现的！</p>

<p>我们使用类对象作为函数参数的时候，以及返回一个对象的时候，代价是很大的，<br/>
因为伴随着对象的创建和销毁，还伴随着复制构造函数的调用， 所以一般使用传引用来规避这种代价！<br/>
引用传递：<br/>
形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p>

<h1>源代码下载地址：</h1>

<blockquote cite='陈浩翔'>
GITHUB源码下载地址:<strong>【<a href='https://github.com/chenhaoxiang/C-Study/tree/master/20170603/test2' target='_blank'>点我进行下载</a>】</strong></p>
</blockquote>


<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【C++】C++构造函数和析构函数]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/05/20/constructor-and-destructor%20-%20%E5%89%AF%E6%9C%AC/"/>
    <updated>2017-05-20T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/05/20/constructor-and-destructor - 副本</id>
    <content type="html"><![CDATA[<p>C++提供构造函数来处理对象的初始化。<br/>
构造函数是一种特殊的成员函数，不需要用户来调用，定义对象时被自动执行。<br/>
构造函数名字与类名相同，无返回类型(void也不能有哦)。</p>

<p>可以由用户自己定义实现，根据需要设计对数据成员进行初始化</p>

<!-- more -->


<hr />

<p>用上个例子来继续写代码进去<br/>
CTime为类名</p>

<h1>无参数的构造函数：</h1>

<p>在.h文件中进行声明：<br/>
CTime();<br/>
在.cpp文件中进行实现：<br/>
<code>
CTime::CTime(){
    m_hour = 0;
    m_minute = 0;
    m_second = 0;
}
</code>
定义对象:<br/>
CTime time;<br/>
构造函数不需要我们去调用，定义一个对象的时候，会自动的去调用一个默认的无参构造函数。内部没有其他任何动作！
一般在构造函数中进行数据的初始化，当然，你还可以进行其他操作。</p>

<p>如果你没写构造函数，在定义一个对象的时候，会自动生成调用一个空构造函数。</p>

<h1>带参数的构造函数</h1>

<p>在.h文件中进行声明： <br/>
CTime(int hour,int minute,int second);</p>

<p>在.cpp文件中进行实现：  <br/>
<code>
CTime::CTime(int hour, int minute, int second){
    m_hour = hour;
    m_minute = minute;
    m_second = second;
}
</code>
定义对象:<br/>
<code>
CTime time(10,50,20);
</code></p>

<p>在一个类中可以有多个构造函数，函数名相同，参数不同，构造函数是可以重载的！</p>

<p>如果你有了其他面向对象语言的基础！前面这些章节都会很容易学的。</p>

<p>可以在声明的时候，给参数一个默认的值：<br/>
<code>
CTime(int hour,int minute,int second = 0);  
</code></p>

<p>在调用的时候，可以只传2个值，这个时候的second就会使用默认的值0；</p>

<p>但是注意：
不能这么写<br/>
<code>
CTime(int hour,int minute =0,int second);   
</code>
上面的写法是错误的！
也就是说，如果你在某个参数给了默认值，则排在它后面的参数你都需要给上默认值才行！</p>

<p>也不能给构造函数的每个参数都给上默认值<br/>
<code>
CTime(int hour=0,int minute=0,int second=0);   
</code>
这样会引起歧义！！！</p>

<h1>析构函数</h1>

<p>也是C++中的一个成员函数。<br/>
析构函数的作用和构造函数相反。<br/>
命名规则与类名相同，但是需要在类名前加上"~&ldquo;符号。</p>

<p>~在C++中是取反运算符。</p>

<p>析构函数一般式执行对象的清理工作。
当对象的生命周期结束之后，会自动调用析构函数。</p>

<p>析构函数的作用不是删除对象，而是说，在对象撤销它所占用的内存之前做一些清理工作，清理之后，这个对象的内存可以被分配给其他对象使用。</p>

<p>在设计类的时候，都会给类提供一个析构函数。</p>

<p>构造函数和析构函数都是可以由用户来定义的，但是调用，都是可以由程序来自动调用的。</p>

<p>构造函数是在定义一个对象的时候执行的，而析构函数是在对象生命周期结束之后，自动执行析构函数。</p>

<p>析构函数没有返回值和参数！</p>

<p>注意：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。</p>

<p>析构函数的作用并不仅限于释放资源，还可以执行用户自己定义的一些操作，比如输出一些信息等。</p>

<p>声明析构函数：
<code>C++ 声明析构函数
~CTime();  
</code>
定义析构函数：<br/>
<code>C++ 定义析构函数
CTime::~CTime(){
    std::cout &lt;&lt; "析构函数被执行了..." &lt;&lt; std::endl;
}
</code></p>

<p>析构函数的执行顺序和构造函数的执行顺序是相反的！</p>

<p>也就是最先被定义的对象，最后被执行析构函数！</p>

<p>用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。构造函数和析构函数对于类来说是不可或缺的！</p>

<p>在函数内部创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。</p>

<p>new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。</p>

<h1>源代码下载地址：</h1>

<blockquote cite='陈浩翔'>
GITHUB源码下载地址:<strong>【<a href='https://github.com/chenhaoxiang/C-Study/tree/master/20170520/test3' target='_blank'>点我进行下载</a>】</strong></p>
</blockquote>


<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
</feed>
