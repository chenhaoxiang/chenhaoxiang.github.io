<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 谙忆-人生之旅]]></title>
  <link href="http://chenhaoxiang.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://chenhaoxiang.github.io/"/>
  <updated>2017-08-31T00:21:10+08:00</updated>
  <id>http://chenhaoxiang.github.io/</id>
  <author>
    <name><![CDATA[陈浩翔]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【问题解决】SSM-@Transactional注解事务无效探讨]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/08/21/Spring-SpringMVC-MyBatis-Transactional-Invalid/"/>
    <updated>2017-08-21T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/08/21/Spring-SpringMVC-MyBatis-Transactional-Invalid</id>
    <content type="html"><![CDATA[<p>Spring SpringMVC MyBatis框架中-@Transactional注解事务无效解决方法</p>

<!-- more -->


<hr />

<p>SpringMVC-Spring-MyBatis框架<br/>
数据库:SQL SERVER 2008<br/>
以前都是用的MySQL数据库，没有出现这个问题，现在换成sql server了，结果事务没有起作用了。</p>

<p>经过一番测试：<br/>
排除以下几个问题:
1.数据库原因，不存在的。MySQL中只有InnoDB引擎支持事务。SqlServer2008的企业版作为收费数据库，不可能不支持事务操作。<br/>
2.异常类型不是unchecked异常，我写的异常是1/0，为了保险起见，我还抛出RuntimeException试了，结果也是没有回滚。<br/>
3.是不是配置文件的没配置好，比如Bean，比如:
<code>
    &lt;!-- 配置事物管理类 --&gt;
    &lt;bean id="transactionManager"
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
        &lt;property name="dataSource" ref="dynamicDataSource" /&gt;
    &lt;/bean&gt;
    &lt;!-- 开启注解式事物扫描 --&gt;
    &lt;tx:annotation-driven transaction-manager="transactionManager"  /&gt;
</code>
检查几遍，排除这个原因。
4.还有一种情况，因为我以前写的都是对一个数据库的操作，现在是一个数据源多个数据库操作，当时有点怀疑我是不是少配置了什么，导致多数据库时无法启动事务，于是便还原到一个数据库，结果事务还是无效，排除此问题</p>

<p>经过一番折腾，在网上找到一篇文章，说原因是applicationContext.xml的父容器先于Servlet的子容器生效，将Service提前加载了。</p>

<p>于是验证了一下，首先去掉Service实现类的@Service注解，在spring.xml(也就是applicationContext.xml，我起名是spring.xml)，配置该类的Bean:
<code>
&lt;bean id="sysUserServiceImp" class="cn.kx59.user.service.imp.SysUserServiceImp"&gt;&lt;/bean&gt;
</code>
结果运行之后，事务起作用了。</p>

<p>原因如下:<br/>
Spring容器优先加载由ServletContextListener（对应applicationContext.xml，我这里是spring.xml）产生的父容器，而SpringMVC（对应spring-mvc.xml）产生的是子容器。<br/>
子容器Controller进行扫描装配时装配的@Service注解的实例是没有经过事务加强处理，即没有事务处理能力的Service，而父容器进行初始化的Service是保证事务的增强处理能力的。如果不在子容器中将Service exclude掉，此时得到的将是原样的无事务处理能力的Service。
所以我们要在扫描的时候在子容器中将Service exclude掉就好了。</p>

<p>也就是在spring-mvc.xml中进行如下修改:
<code>
    &lt;!--扫描Controller--&gt;
    &lt;context:component-scan base-package="cn.kx59"&gt;
        &lt;context:include-filter type="annotation"
                                expression="org.springframework.stereotype.Controller" /&gt;
        &lt;!--下面这个是防止事务没起作用，spring.xml的父容器先于Servlet的子容器生效，将Service提前加载了。这里不用再进行加载装配--&gt;
        &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Service" /&gt;
    &lt;/context:component-scan&gt;
</code></p>

<p>注意: 请将@Transactional注解写在实现类的方法或类上！不建议写在接口类中！  <br/>
Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因此，请接受Spring团队的建议并且在具体的类上使用 @Transactional 注解。</p>

<p>在以上解决方法中，若将@Transactional 注解写在接口上，则无法实现事务。所以请将 @Transactional 注解写在实现类中！</p>

<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【问题解决】Mybatis一对多/多对多查询时只查出了一条数据]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/08/08/mybatis-multilevel-query-question/"/>
    <updated>2017-08-08T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/08/08/mybatis-multilevel-query-question</id>
    <content type="html"><![CDATA[<p>问题描述:
如果三表(包括了关系表)级联查询，主表和明细表的主键都是id的话，明细表的多条数据只能查询出来第一条/最后一条数据。</p>

<!-- more -->


<hr />

<p>三个表，权限表(Permission)，权限组表(PermissionGroup)，权限组与权限的关系表(PermissionPermissionGroupKey)</p>

<p>实体类就不写上来了。</p>

<p>原出错映射文件:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>  <span class="nt">&lt;resultMap</span> <span class="na">id=</span><span class="s">&quot;permissionGroupResultMap&quot;</span> <span class="na">type=</span><span class="s">&quot;cn.kx59.admin.entity.PermissionGroup&quot;</span> <span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;id</span> <span class="na">column=</span><span class="s">&quot;id&quot;</span> <span class="na">property=</span><span class="s">&quot;id&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;INTEGER&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;name&quot;</span> <span class="na">property=</span><span class="s">&quot;name&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;decipher&quot;</span> <span class="na">property=</span><span class="s">&quot;decipher&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;create_time&quot;</span> <span class="na">property=</span><span class="s">&quot;createTime&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;TIMESTAMP&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="c">&lt;!-- 一个权限组 对应多个权限--&gt;</span>
</span><span class='line'>    <span class="nt">&lt;collection</span> <span class="na">property=</span><span class="s">&quot;permissionArrayList&quot;</span> <span class="na">ofType=</span><span class="s">&quot;cn.kx59.admin.entity.Permission&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;id</span> <span class="na">column=</span><span class="s">&quot;id&quot;</span> <span class="na">property=</span><span class="s">&quot;id&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;INTEGER&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;url&quot;</span> <span class="na">property=</span><span class="s">&quot;url&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;name&quot;</span> <span class="na">property=</span><span class="s">&quot;name&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;explain&quot;</span> <span class="na">property=</span><span class="s">&quot;explain&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;decipher&quot;</span> <span class="na">property=</span><span class="s">&quot;decipher&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;create_time&quot;</span> <span class="na">property=</span><span class="s">&quot;createTime&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;TIMESTAMP&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/collection&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/resultMap&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>  <span class="c">&lt;!--查询所有的权限组以及权限组包含的权限--&gt;</span>
</span><span class='line'>  <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">&quot;selectAllPermissionGroupAndPermission&quot;</span> <span class="na">resultMap=</span><span class="s">&quot;permissionGroupResultMap&quot;</span> <span class="nt">&gt;</span>
</span><span class='line'>        SELECT *
</span><span class='line'>  FROM [QPWebDB].[dbo].[permission_group] pg
</span><span class='line'>  left join [QPWebDB].[dbo].[permission_permission_group] ppg on pg.id=ppg.permission_group_id
</span><span class='line'>  left join [QPWebDB].[dbo].[permission] p on p.permission_id=ppg.permission_id
</span><span class='line'>  <span class="nt">&lt;/select&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>这是因为主表和明细表的id字段名相同造成的。<br/>
问题的关键在于resultMap中如果不定义类似主键之类的能够区分每一条结果集的字段的话，会引起后面一条数据覆盖前面一条数据的现象。</p>

<p>解决方法一：<br/>
修改主表或者明细表的id名，保证不一致就行</p>

<p>解决方法二：<br/>
查询结果起别名 <br/>
修改映射文件如下：<br/>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>  <span class="nt">&lt;resultMap</span> <span class="na">id=</span><span class="s">&quot;permissionGroupResultMap&quot;</span> <span class="na">type=</span><span class="s">&quot;cn.kx59.admin.entity.PermissionGroup&quot;</span> <span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;id</span> <span class="na">column=</span><span class="s">&quot;id&quot;</span> <span class="na">property=</span><span class="s">&quot;id&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;INTEGER&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;name&quot;</span> <span class="na">property=</span><span class="s">&quot;name&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;decipher&quot;</span> <span class="na">property=</span><span class="s">&quot;decipher&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;create_time&quot;</span> <span class="na">property=</span><span class="s">&quot;createTime&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;TIMESTAMP&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="c">&lt;!-- 一个权限组 对应多个权限--&gt;</span>
</span><span class='line'>    <span class="nt">&lt;collection</span> <span class="na">property=</span><span class="s">&quot;permissionArrayList&quot;</span> <span class="na">ofType=</span><span class="s">&quot;cn.kx59.admin.entity.Permission&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>      <span class="nt">&lt;id</span> <span class="na">column=</span><span class="s">&quot;p_id&quot;</span> <span class="na">property=</span><span class="s">&quot;id&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;INTEGER&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;url&quot;</span> <span class="na">property=</span><span class="s">&quot;url&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;name&quot;</span> <span class="na">property=</span><span class="s">&quot;name&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;explain&quot;</span> <span class="na">property=</span><span class="s">&quot;explain&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;decipher&quot;</span> <span class="na">property=</span><span class="s">&quot;decipher&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;VARCHAR&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>      <span class="nt">&lt;result</span> <span class="na">column=</span><span class="s">&quot;create_time&quot;</span> <span class="na">property=</span><span class="s">&quot;createTime&quot;</span> <span class="na">jdbcType=</span><span class="s">&quot;TIMESTAMP&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/collection&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/resultMap&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>  <span class="c">&lt;!--查询所有的权限组以及权限组包含的权限--&gt;</span>
</span><span class='line'>  <span class="nt">&lt;select</span> <span class="na">id=</span><span class="s">&quot;selectAllPermissionGroupAndPermission&quot;</span> <span class="na">resultMap=</span><span class="s">&quot;permissionGroupResultMap&quot;</span> <span class="nt">&gt;</span>
</span><span class='line'>        SELECT pg.*,
</span><span class='line'>  p.id p_id,
</span><span class='line'>  p.url,
</span><span class='line'>  p.name,
</span><span class='line'>  p.explain,
</span><span class='line'>  p.decipher,
</span><span class='line'>  p.create_time
</span><span class='line'>  FROM [QPWebDB].[dbo].[permission_group] pg
</span><span class='line'>  left join [QPWebDB].[dbo].[permission_permission_group] ppg on pg.id=ppg.permission_group_id
</span><span class='line'>  left join [QPWebDB].[dbo].[permission] p on p.id=ppg.permission_id
</span><span class='line'>  <span class="nt">&lt;/select&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>如上两种方法均能解决这个问题，希望对你有帮助 <br/>
有知道出现这个问题的原理的大佬欢迎在评论区解释下，O(∩_∩)O谢谢</p>

<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【小工具】CSDN博客导出工具-Java集成Maven开发]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/07/28/CSDNBlogExport/"/>
    <updated>2017-07-28T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/07/28/CSDNBlogExport</id>
    <content type="html"><![CDATA[<p>CSDN博客导出工具<br/>
之前一直想把CSDN的博客导入到自己的网站中，可是由于博客比较多，后面受朋友老郭启发，就找了个时间用Java开发了这款小工具。</p>

<!-- more -->


<hr />

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>


<h1>CSDNBlogExport</h1>

<p>CSDN博客导出工具</p>

<p>之前一直想把CSDN的博客导入到自己的网站中，可是由于博客比较多，后面受朋友老郭启发，就找了个时间用Java开发了这款小工具。<br/>
Had been trying to CSDN blog into their website, but because of the blog is more, inspired by my friend guo behind, will find a time this kind of small tools with Java development.</p>

<h1>only use</h1>

<p>直接下载CSDNBlogExport.7z解压使用即可。 <br/>
Direct download CSDNBlogExport.7z decompression can be used.<br/>
<img src="http://i.imgur.com/H5mMN3E.png" alt="" /></p>

<p><img src="http://i.imgur.com/MBLoPTU.png" alt="" /></p>

<p>经过测试，667篇博客，开50个线程，在54秒左右可以全部导出到文件。<br/>
Tested, 667 blog, open 50 threads, in 54 seconds can all exported to a file.</p>

<p>博客文件导出的存储规则是:<br/>
软件运行目录\blog\年-月\年-月-日 博客标题名.markdown <br/>
Blog file exported storage rule is:<br/>
Software running directory/blog/year-month/year-month-day blog title name.markdown</p>

<p><img src="http://i.imgur.com/tWkpxob.png" alt="" /></p>

<h1>开发</h1>

<p>CSDNBlogExport目录下是完整的程序代码<br/>
使用了WebMagic爬虫框架，本来自己写HttpURLConnection工具类也能实现的，只是比较耗时，偷个小懒，既然别人有更好的工具，为什么不用呢<br/>
技术含量呢，可以说基本没有什么，但是也是花了大半天时间做的。<br/>
中间还遇到部分玩家无法导出博客的情况，因为CSDN对于用户的链接命名分了2种情况，当时写的时候没有发现，是测试别人博客的时候发现的，经过半小时解决了这个问题。</p>

<p>虽然很想把这个程序完善，但是由于时间限制还是不能做太多事。<br/>
不保证本版本一直能使用下去，如果某天本程序不能使用了(肯定是CSDN对返回的数据进行了处理或者进行了权限控制)，请留言或者联系我QQ:619699629或者邮箱:<a href="&#109;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x75;&#105;&#102;&#x75;&#x74;&#x75;&#x72;&#101;&#64;&#x75;&#x69;&#x66;&#117;&#116;&#x75;&#114;&#x65;&#46;&#x63;&#111;&#x6d;">&#117;&#x69;&#x66;&#x75;&#x74;&#117;&#x72;&#101;&#64;&#117;&#x69;&#102;&#117;&#x74;&#117;&#114;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a><br/>
我会利用空闲时间跟上csdn对博客的升级，以保证能继续使用</p>

<p>此版本为1.0版本，希望用的朋友遇到bug，在这里留言或联系我，我会及时修复。</p>

<p>也欢迎朋友加入进来与我一起完善本程序。</p>

<p>本小程序可导出任意CSDN用户的博客，但是仅供学习使用。
免责声明:如果导出博客侵犯他人权益，引起纠纷的，一概与本人无关。</p>

<h1>development</h1>

<p>CSDNBlogExport directory is a complete program code
Used WebMagic crawler frame, original, write their own HttpURLConnection tools can be achieved only takes time, steal a little lazy, now that people have a better tools, why not
Technical content, it was basically have no what, but also spent most of time to do. <br/>
And in case of some players cannot export blog because CSDN links named points to the user for two kinds of circumstances, then write not found, is to test others while on a blog, solved the problem after half an hour.</p>

<p>Although very want to send this application is perfect, but due to time constraints or can&rsquo;t do too many things. <br/>
Does not guarantee that this version has been able to use, if one day can&rsquo;t use this program (must be CSDN on the returned data processing or access control), please leave a message or contact me QQ: 619699629 or email: <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x75;&#x69;&#x66;&#117;&#116;&#x75;&#x72;&#x65;&#64;&#x75;&#105;&#102;&#117;&#x74;&#x75;&#114;&#101;&#46;&#x63;&#x6f;&#109;">&#x75;&#105;&#x66;&#117;&#116;&#x75;&#x72;&#x65;&#x40;&#x75;&#x69;&#102;&#x75;&#x74;&#117;&#114;&#x65;&#46;&#99;&#x6f;&#x6d;</a></p>

<p>I will use free time keep up with the CSDN on updating the blog, to ensure that can continue to use</p>

<p>This version is 1.0 version, hope to meet with friends bug, leave a message or contact me here, I&rsquo;ll repair in time.<br/>
Also welcome friends to join in with me in perfect this procedure.<br/>
This small program can export any CSDN user&rsquo;s blog, but only for the use of learning.<br/>
Disclaimer: if the export blog infringement of rights and interests of others, cause disputes, all has nothing to do with himself.</p>

<h1>Bug修复记录</h1>

<p>2017.7.31：
修复html编辑器写完博客后导出博客不全的bug<br/>
现在版本 v1.1<br/>
感谢CSDN博主<a href="http://blog.csdn.net/zuochao_2013" target='_blank'>[三名狂客]</a>提出的Bug</p>

<blockquote><p>2017.8.16：<br/>
进行版本升级，因为CSDN把一个分页的bug给堵上了，原来的版本不能使用，请下载最新版本2.0<br/>
现在版本 v2.0  <br/>
感谢CSDN博主<a href="http://blog.csdn.net/u011637069" target='_blank'>[龙腾四海365]</a>提出的Bug</p></blockquote>

<p>本次bug修复后，时间会延长一点，因为我在里面把分页的线程写死了，50个线程，有兴趣的可以自己扩展。<br/>
经过测试，在输入50线程时，668篇博客的爬取时间为92S。<br/>
<img src="http://i.imgur.com/XPP3svY.png" alt="" /></p>

<h1>源代码下载地址：</h1>

<blockquote cite='陈浩翔'>
GITHUB项目地址:<strong>【<a href='https://github.com/chenhaoxiang/CSDNBlogExport' target='_blank'>点我进行访问</a>】</strong>
</blockquote>


<p>如果无法访问，请翻墙哦</p>

<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【问题解决】MyBatis分页查询SQL Server2008时出现'@P0' 附近有语法错误]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/07/04/MyBatis-SQL-Server2008-show-p0-error/"/>
    <updated>2017-07-04T13:38:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/07/04/MyBatis-SQL-Server2008-show-p0-error</id>
    <content type="html"><![CDATA[<p>MyBatis分页查询SQL Server2008时出现'@P0' 附近有语法错误"<br/>
Error querying database.  Cause: com.microsoft.sqlserver.jdbc.SQLServerException: &lsquo;@P0&rsquo; 附近有语法错误。</p>

<!-- more -->


<hr />

<p>错误如下:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'>org.springframework.jdbc.UncategorizedSQLException:<span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;h3&gt;</span>Error querying database.  Cause: com.microsoft.sqlserver.jdbc.SQLServerException: <span class="ni">&amp;lsquo;</span>@P0<span class="ni">&amp;rsquo;</span> 附近有语法错误。<span class="nt">&lt;/h3&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;h3&gt;</span>The error may exist in file [E:\Client\KaiXinHuYu\target\classes\cn\kx59\user\mapping\AccountsInfoMapper.xml]<span class="nt">&lt;/h3&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;h3&gt;</span>The error may involve cn.kx59.user.dao.AccountsInfoMapper.selectPageData-Inline<span class="nt">&lt;/h3&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;h3&gt;</span>The error occurred while setting parameters<span class="nt">&lt;/h3&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;h3&gt;</span>SQL: select top ?       UserID, GameID, ProtectID, PasswordID, SpreaderID, Accounts, NickName, RegAccounts,      UnderWrite, PassPortID, Compellation, LogonPass, InsurePass, FaceID, CustomID, Present,      UserMedal, Experience, LoveLiness, UserRight, MasterRight, ServiceRight, MasterOrder,      MemberOrder, MemberOverDate, MemberSwitchDate, CustomFaceVer, Gender, Nullity, NullityOverDate,      StunDown, MoorMachine, IsAndroid, WebLogonTimes, GameLogonTimes, PlayTimeCount, OnLineTimeCount,      LastLogonIP, LastLogonDate, LastLogonMobile, LastLogonMachine, RegisterIP, RegisterDate,      RegisterMobile, RegisterMachine     from AccountsInfo where UserID not in(select top ? UserID from AccountsInfo)<span class="nt">&lt;/h3&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;h3&gt;</span>Cause: com.microsoft.sqlserver.jdbc.SQLServerException: <span class="ni">&amp;lsquo;</span>@P0<span class="ni">&amp;rsquo;</span> 附近有语法错误。<span class="nt">&lt;/h3&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span>; uncategorized SQLException for SQL []; SQL state [S0001]; error code [102]; <span class="ni">&amp;lsquo;</span>@P0<span class="ni">&amp;rsquo;</span> 附近有语法错误。; nested exception is com.microsoft.sqlserver.jdbc.SQLServerException: <span class="ni">&amp;lsquo;</span>@P0<span class="ni">&amp;rsquo;</span> 附近有语法错误。<span class="nt">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;pre&gt;&lt;code&gt;</span>at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:84)
</span><span class='line'>at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81)
</span><span class='line'>at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81)
</span><span class='line'>at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:73)
</span><span class='line'>at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:371)
</span><span class='line'>at $Proxy24.selectList(Unknown Source)
</span><span class='line'>at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:198)
</span><span class='line'>at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:122)
</span><span class='line'>at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:64)
</span><span class='line'>at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:53)
</span><span class='line'>at $Proxy25.selectPageData(Unknown Source)
</span><span class='line'>at cn.kx59.user.service.imp.AccountsInfoServiceImp.selectPageData(AccountsInfoServiceImp.java:33)
</span><span class='line'>at cn.kx59.user.service.imp.AccountsInfoServiceImp$$FastClassBySpringCGLIB$$f0736e8f.invoke(<span class="ni">&amp;lt;</span>generated<span class="ni">&amp;gt;</span>)
</span><span class='line'>at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
</span><span class='line'>at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:718)
</span><span class='line'>at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)
</span><span class='line'>at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52)
</span><span class='line'><span class="nt">&lt;/code&gt;&lt;/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;</span><span class="ni">&amp;hellip;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>出错代码的MyBatis中查询语句为：
<code>
  &lt;!--分页查询--&gt;
  &lt;select id="selectPageData" resultMap="BaseResultMap" parameterType="java.lang.Integer"&gt;
    select top #{pageSize} &lt;include refid="Base_Column_List" /&gt; from AccountsInfo where UserID not in(select top #{startN} UserID from AccountsInfo)
  &lt;/select&gt;
</code></p>

<p>其实这是因为top后面不能跟占位符'？'号的原因，可以看调试的sql语句，mybatis为了防止注入，会先使用?号占位符。</p>

<p>错误解释如下：<br/>
在Java中对数据库查询时经常使用“Select Top ？ * From 表名 Where 列名 = ？”的SQL语句，此时的问号是PreparedStatement预编译对象的参数占位符，需要使用setXX()系列方法对其赋值后再执行。但是，Top后面是不允许使用问号占位符的，此处的错误就是由此引起的。</p>

<p>解决方法:<br/>
使用<code>$</code>代替#，使用#传入参数是，sql语句解析是会加上"&ldquo;,当成字符串来解析，会加入占位符?，再使用setXX()方法后赋值再执行，#{}传参能防止sql注入。<br/>
而<code>${}</code>这种方式 是直接传值！在这里无法使用占位符的情况下，可以使用<code>$</code>，但是自己写好防范哦，以免被注入了</p>

<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【Redis】Java之Redis工具类]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2017/05/18/redisUtil/"/>
    <updated>2017-05-18T21:29:54+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2017/05/18/redisUtil</id>
    <content type="html"><![CDATA[<p>我就不介绍Redis是什么了。
(一个月前写的工具类，一直忘记分享了，算是比较全的Java-Redis工具类)
直接上代码吧。</p>

<p>先给出在spring 中配置Redis的代码。你在其他类用的时候，直接用注解自动注入就可以了。</p>

<!-- more -->


<hr />

<h2>redis.properties</h2>

<pre><code>##访问地址
redis.host=127.0.0.1
##访问端口
redis.port=6379
##注意，如果没有password，此处不设置值，但这一项要保留
redis.password=你的密码

#最大能够保持idel状态的对象数
redis.maxIdle=150
#连接池的最大数据库连接数。设为0表示无限制 最大分配的对象数
redis.maxActive=300
#连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true
redis.blockWhenExhausted=true
#获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间,  默认-1
redis.maxWait=10000
#在borrow一个jedis实例时，是否提前进行alidate操作；如果为true，则得到的jedis实例均是可用的；
redis.testOnBorrow=true
#jedis调用returnObject方法时，是否进行有效检查 #
redis.testOnReturn=true
#在空闲时检查有效性, 默认false
redis.testWhileIdle=true
#表示idle object evitor两次扫描之间要sleep的毫秒数；
redis.timeBetweenEvictionRunsMillis=30000
#表示一个对象至少停留在idle状态的最短时间，
#然后才能被idle object evitor扫描并驱逐；这一项只有在timeBetweenEvictionRunsMillis大于0时才有意义；
redis.minEvictableIdleTimeMillis=-1

#连接空闲的最小时间,达到此值后空闲链接将会被移除,且保留“minIdle”个空闲连接数。
#如果minEvictableIdleTimeMillis&gt;0，则此项设置无意义，且只有在timeBetweenEvictionRunsMillis大于0时才有意义；
redis.softMinEvictableIdleTimeMillis=60000
</code></pre>

<h2>spring.xml中配置redis</h2>

<pre><code class="xml spring.xml中配置redis">  &lt;!-- S Redis 配置--&gt;
    &lt;!-- scanner redis properties  --&gt;
    &lt;context:property-placeholder location="classpath:redis.properties" ignore-unresolvable="true"/&gt;
    &lt;!--（1）如果你有多个数据源需要通过
    &lt;context:property-placeholder管理，且不愿意放在一个配置文件里，
    那么一定要加上ignore-unresolvable=“true"(每一个都需要加这个属性)--&gt;
    &lt;!--（2）注意新版的（从3.0版本开始弃用）JedisPoolConfig的property name，
    不是maxActive而是maxTotal，而且没有maxWait属性，建议看一下Jedis源码。--&gt;
    &lt;!-- redis连接池 --&gt;
    &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;
        &lt;property name="maxTotal" value="${redis.maxActive}"&gt;&lt;/property&gt;
        &lt;property name="maxIdle" value="${redis.maxIdle}"&gt;&lt;/property&gt;
        &lt;property name="maxWaitMillis" value="${redis.maxWait}"&gt;&lt;/property&gt;
        &lt;property name="testOnBorrow" value="${redis.testOnBorrow}"&gt;&lt;/property&gt;
        &lt;property name="testOnReturn" value="${redis.testOnReturn}"&gt;&lt;/property&gt;
        &lt;property name="blockWhenExhausted" value="${redis.blockWhenExhausted}"&gt;&lt;/property&gt;
        &lt;property name="testWhileIdle" value="${redis.testWhileIdle}"&gt;&lt;/property&gt;
        &lt;property name="timeBetweenEvictionRunsMillis" value="${redis.timeBetweenEvictionRunsMillis}"&gt;&lt;/property&gt;
        &lt;property name="minEvictableIdleTimeMillis" value="${redis.minEvictableIdleTimeMillis}"&gt;&lt;/property&gt;
        &lt;property name="softMinEvictableIdleTimeMillis" value="${redis.softMinEvictableIdleTimeMillis}"&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;!-- redis连接工厂 --&gt;
    &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"
          p:host-name="${redis.host}" p:port="${redis.port}" p:password="${redis.password}"  p:pool-config-ref="jedisPoolConfig"
          p:usePool="true"/&gt;
    &lt;!-- redis操作模板，这里采用尽量面向对象的模板 --&gt;
    &lt;!--&lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt;
        使用上句会无法使用模糊匹配
    --&gt;
    &lt;!--
        p:enable-transaction-support="false"
        设置setEnableTransactionSupport(true)，当前线程会强制先 MULTI命令
     --&gt;
    &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.StringRedisTemplate"
          p:enable-transaction-support="true"&gt;
        &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
        &lt;!-- 如果不配置Serializer，那么存储的时候只能使用String，如果用对象类型存储，那么会提示错误 can't cast to String！！！--&gt;
        &lt;property name="keySerializer"&gt;
            &lt;!--对key的默认序列化器。默认值是StringSerializer--&gt;
            &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt;
        &lt;/property&gt;
        &lt;!--是对value的默认序列化器，默认值是取自DefaultSerializer的JdkSerializationRedisSerializer。--&gt;
        &lt;property name="valueSerializer"&gt;
            &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"/&gt;
        &lt;/property&gt;
        &lt;!--存储Map时key需要的序列化配置--&gt;
        &lt;property name="hashKeySerializer"&gt;
            &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt;
        &lt;/property&gt;
        &lt;!--存储Map时value需要的序列化配置--&gt;
        &lt;property name="hashValueSerializer"&gt;
            &lt;bean class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"/&gt;
        &lt;/property&gt;
        &lt;!--开启事务
        系统自动帮我们拿到了事务中绑定的连接。可以在一个方法的多次对Redis增删该查中，始终使用同一个连接。
        --&gt;
        &lt;property name="enableTransactionSupport" value="true"/&gt;
        &lt;!--在Spring中@Transactional 也是可以进行事物控制的。--&gt;
    &lt;/bean&gt;
    &lt;!-- 缓存管理器: 使用redis 当做缓存 --&gt;
    &lt;!--&lt;bean id="cacheManager" class="org.springframework.data.redis.cache.RedisCacheManager"&gt;--&gt;
        &lt;!--&lt;constructor-arg ref="redisTemplate"/&gt;--&gt;
    &lt;!--&lt;/bean&gt;--&gt;
    &lt;!-- cache配置 --&gt;
    &lt;!-- E Redis 配置--&gt;
</code></pre>

<h2>Redis操作的接口</h2>

<pre><code class="java Redis操作的接口">
package com.uifuture.utils.redis;

import org.springframework.data.redis.connection.DataType;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.data.redis.core.ZSetOperations;
import org.springframework.util.CollectionUtils;

import java.io.Serializable;
import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * Created with IntelliJ IDEA.
 * User: 陈浩翔.
 * Date: 2017/4/10.
 * Time: 上午 12:11.
 * Explain: Redis操作的接口
 */
public interface RedisCommand&lt;K, V&gt; {

    /**
     * 用户排序通过注册时间的 权重值
     * @param date
     * @return
     */
    double getCreateTimeScore(long date);
    /**
     * 获取Redis中所有的键的key
     * @return
     */
    Set&lt;K&gt; getAllKeys();

    /**
     * 获取所有的普通key-value
     * @return
     */
    Map&lt;K,V&gt; getAllString();

    /**
     * 获取所有的Set -key-value
     * @return
     */
    Map&lt;K,Set&lt;V&gt;&gt; getAllSet();
    /**
     * 获取所有的ZSet正序  -key-value 不获取权重值
     * @return
     */
    Map&lt;K,Set&lt;V&gt;&gt; getAllZSetReverseRange();
    /**
     * 获取所有的ZSet倒序  -key-value 不获取权重值
     * @return
     */
    Map&lt;K,Set&lt;V&gt;&gt; getAllZSetRange();

    /**
     * 获取所有的List -key-value
     * @return
     */
    Map&lt;K,List&lt;V&gt;&gt; getAllList();

    /**
     * 获取所有的Map -key-value
     * @return
     */
    Map&lt;K,Map&lt;K,V&gt;&gt; getAllMap();

    /**
     * 添加一个list
     * @param key
     * @param objectList
     */
    void addList(K key, List&lt;V&gt; objectList);
    /**
     * 向list中增加值
     * @param key
     * @param obj
     * @return 返回在list中的下标
     */
    long addList(K key,V obj);
    /**
     *
     * 向list中增加值
     * @param key
     * @param obj
     * @return 返回在list中的下标
     */
    long addList(K key,V ...obj);

    /**
     *
     * 输出list
     * @param key List的key
     * @param s 开始下标
     * @param e 结束的下标
     * @return
     */
    List&lt;V&gt; getList(K key, long s, long e);
    /**
     * 输出完整的list
     * @param key
     */
    List&lt;V&gt; getList(K key);
    /**
     * 获取list集合中元素的个数
     * @param key
     * @return
     */
    long getListSize(K key);
    /**
     * 移除list中某值
     * 移除list中 count个value为object的值,并且返回移除的数量,
     * 如果count为0,或者大于list中为value为object数量的总和,
     * 那么移除所有value为object的值,并且返回移除数量
     * @param key
     * @param object
     * @return 返回移除数量
     */
    long removeListValue(K key,V object);
    /**
     * 移除list中某值
     * @param key
     * @param object
     * @return 返回移除数量
     */
    long removeListValue(K key,V... object);

    /**
     * 批量删除key对应的value
     * @param keys
     */
    void remove(final K... keys);
    /**
     * 删除缓存
     * 根据key精确匹配删除
     * @param key
     */
    void remove(final K key);

    /**
     * 通过分数删除ZSet中的值
     * @param key
     * @param s
     * @param e
     */
    void removeZSetRangeByScore(String key,double s , double e);
    /**
     * 设置Set的过期时间
     * @param key
     * @param time
     * @return
     */
    Boolean setSetExpireTime(String key,Long time);

    /**
     * 设置ZSet的过期时间
     * @param key
     * @param time
     * @return
     */
    Boolean setZSetExpireTime(String key,Long time);
    /**
     * 判断缓存中是否有key对应的value
     * @param key
     * @return
     */
    boolean exists(final K key);

    /**
     * 读取String缓存 可以是对象
     * @param key
     * @return
     */
    V get(final K key);
    /**
     * 读取String缓存 可以是对象
     * @param key
     * @return
     */
    List&lt;V&gt; get(final K... key);
    /**
     * 读取缓存 可以是对象 根据正则表达式匹配
     * @param regKey
     * @return
     */
    List&lt;Object&gt; getByRegular(final K regKey);


    /**
     * 写入缓存 可以是对象
     * @param key
     * @param value
     */
    void set(final K key, V value);

    /**
     * 写入缓存
     * @param key
     * @param value
     * @param expireTime 过期时间 -单位s
     * @return
     */
    void set(final K key, V value, Long expireTime);

    /**
     * 设置一个key的过期时间（单位：秒）
     * @param key
     * @param expireTime
     * @return
     */
    boolean setExpireTime(K key, Long expireTime);

    /**
     * 获取key的类型
     * @param key
     * @return
     */
    DataType getType(K key);

    /**
     * 删除map中的某个对象
     * @param key   map对应的key
     * @param field map中该对象的key
     */
    void removeMapField(K key, V... field);
    /*
     * 获取map对象
     * @param key map对应的key
     * @return
     */
    Map&lt;K,V&gt; getMap(K key);
    /*
     * 获取map对象
     * @param key map对应的key
     * @return
     */
    Long getMapSize(K key);
    /**
     * 获取map缓存中的某个对象
     * @param key map对应的key
     * @param field map中该对象的key
     * @return
     */
    &lt;T&gt; T getMapField(K key, K field);
    /**
     * 判断map中对应key的key是否存在
     * @param key map对应的key
     * @return
     */
    Boolean hasMapKey(K key,K field);

    /**
     * 获取map对应key的value
     * @param key map对应的key
     * @return
     */
    List&lt;V&gt; getMapFieldValue(K key);
    /**
     * 获取map的key
     * @param key map对应的key
     * @return
     */
    Set&lt;V&gt; getMapFieldKey(K key);
    /**
     * 添加map
     * @param key
     * @param map
     */
    void addMap(K key, Map&lt;K,V&gt; map);
    /**
     * 向key对应的map中添加缓存对象
     * @param key   cache对象key
     * @param field map对应的key
     * @param value     值
     */
    void addMap(K key, K field, Object value);
    /**
     * 向key对应的map中添加缓存对象
     * @param key   cache对象key
     * @param field map对应的key
     * @param time 过期时间-整个MAP的过期时间
     * @param value     值
     */
    void addMap(K key, K field, V value,long time);

    /**
     * 向set中加入对象
     * @param key  对象key
     * @param obj  值
     */
    void addSet(K key, V... obj);

    /**
     * 处理事务时锁定key
     * @param key
     */
    void watch(String key);

    /**
     * 移除set中的某些值
     * @param key  对象key
     * @param obj  值
     */
    long removeSetValue(K key, V obj);
    /**
     * 移除set中的某些值
     * @param key  对象key
     * @param obj  值
     */
    long removeSetValue(K key, V... obj);

    /**
     * 获取set的对象数
     * @param key  对象key
     */
    long getSetSize(K key);

    /**
     * 判断set中是否存在这个值
     * @param key  对象key
     */
    Boolean hasSetValue(K key,V obj);
    /**
     * 获得整个set
     * @param key  对象key
     */
    Set&lt;V&gt; getSet(K key);

    /**
     * 获得set 并集
     * @param key
     * @param otherKey
     * @return
     */
    Set&lt;V&gt; getSetUnion(K key,K otherKey);

    /**
     * 获得set 并集
     * @param key
     * @param set
     * @return
     */
    Set&lt;V&gt; getSetUnion(K key,Set&lt;Object&gt; set);

    /**
     * 获得set 交集
     * @param key
     * @param otherKey
     * @return
     */
    Set&lt;V&gt; getSetIntersect(K key,K otherKey);

    /**
     * 获得set 交集
     * @param key
     * @param set
     * @return
     */
    Set&lt;V&gt; getSetIntersect(K key,Set&lt;Object&gt; set);

    /**
     * 模糊移除 支持*号等匹配移除
     * @param blears
     */
    void removeBlear(K... blears);

    /**
     * 修改key名 如果不存在该key或者没有修改成功返回false
     * @param oldKey
     * @param newKey
     * @return
     */
    Boolean renameIfAbsent(String oldKey,String newKey);
    /**
     * 模糊移除 支持*号等匹配移除
     * @param blear
     */
    void removeBlear(K blear);

    /**
     * 根据正则表达式来移除key-value
     * @param blears
     */
    void removeByRegular(String... blears);

    /**
     * 根据正则表达式来移除key-value
     * @param blears
     */
    void removeByRegular(String blears);

    /**
     * 根据正则表达式来移除 Map中的key-value
     * @param key
     * @param blears
     */
    void removeMapFieldByRegular(K key,K... blears);

    /**
     * 根据正则表达式来移除 Map中的key-value
     * @param key
     * @param blear
     */
    void removeMapFieldByRegular(K key,K blear);

    /**
     * 移除key 对应的value
     * @param key
     * @param value
     * @return
     */
    Long removeZSetValue(K key, V... value);
    /**
     * 移除key ZSet
     * @param key
     * @return
     */
    void removeZSet(K key);
    /**
     *删除，键为K的集合，索引start&lt;=index&lt;=end的元素子集
     * @param key
     * @param start
     * @param end
     * @return
     */
    void removeZSetRange(K key,Long start,Long end);

    /**
     * 并集 将key对应的集合和key1对应的集合合并到key2中
     * 如果分数相同的值，都会保留
     * 原来key2的值会被覆盖
     * @param key
     * @param key1
     * @param key2
     */
    void setZSetUnionAndStore(String key,String key1, String key2);

    /**
     * 获取整个有序集合ZSET，正序
     * @param key
     */
    &lt;T&gt; T getZSetRange(K key);

    /**
     * 获取有序集合ZSET
     * 键为K的集合，索引start&lt;=index&lt;=end的元素子集，正序
     * @param key
     * @param start 开始位置
     * @param end 结束位置
     */
    &lt;T&gt; T getZSetRange(K key,long start,long end);
    /**
     * 获取整个有序集合ZSET，倒序
     * @param key
     */
    Set&lt;Object&gt; getZSetReverseRange(K key);

    /**
     * 获取有序集合ZSET
     * 键为K的集合，索引start&lt;=index&lt;=end的元素子集，倒序
     * @param key
     * @param start 开始位置
     * @param end 结束位置
     */
    Set&lt;V&gt; getZSetReverseRange(K key,long start,long end);

    /**
     * 通过分数(权值)获取ZSET集合 正序 -从小到大
     * @param key
     * @param start
     * @param end
     * @return
     */
    Set&lt;V&gt; getZSetRangeByScore(String key, double start, double end);

    /**
     * 通过分数(权值)获取ZSET集合 倒序 -从大到小
     * @param key
     * @param start
     * @param end
     * @return
     */
    Set&lt;V&gt; getZSetReverseRangeByScore(String key, double start, double end);

    /**
     * 键为K的集合，索引start&lt;=index&lt;=end的元素子集
     * 返回泛型接口（包括score和value），正序
     * @param key
     * @param start
     * @param end
     * @return
     */
    Set&lt;ZSetOperations.TypedTuple&lt;V&gt;&gt; getZSetRangeWithScores(K key, long start, long end);
    /**
     * 键为K的集合，索引start&lt;=index&lt;=end的元素子集
     * 返回泛型接口（包括score和value），倒序
     * @param key
     * @param start
     * @param end
     * @return
     */
    Set&lt;ZSetOperations.TypedTuple&lt;V&gt;&gt; getZSetReverseRangeWithScores(K key, long start, long end);

    /**
     * 键为K的集合
     * 返回泛型接口（包括score和value），正序
     * @param key
     * @return
     */
    Set&lt;ZSetOperations.TypedTuple&lt;V&gt;&gt; getZSetRangeWithScores(K key);
    /**
     * 键为K的集合
     * 返回泛型接口（包括score和value），倒序
     * @param key
     * @return
     */
    Set&lt;ZSetOperations.TypedTuple&lt;V&gt;&gt; getZSetReverseRangeWithScores(K key);

    /**
     * 键为K的集合，sMin&lt;=score&lt;=sMax的元素个数
     * @param key
     * @param sMin
     * @param sMax
     * @return
     */
    long getZSetCountSize(K key,double sMin,double sMax);

    /**
     * 获取Zset 键为K的集合元素个数
     * @param key
     * @return
     */
    long getZSetSize(K key);

    /**
     * 获取键为K的集合，value为obj的元素分数
     * @param key
     * @param value
     * @return
     */
    double getZSetScore(K key,V value);

    /**
     * 元素分数增加，delta是增量
     * @param key
     * @param value
     * @param delta
     * @return
     */
    double incrementZSetScore(K key,V value,double delta);

    /**
     * 添加有序集合ZSET
     * 默认按照score升序排列，存储格式K(1)==V(n)，V(1)=S(1)
     * @param key
     * @param score
     * @param value
     * @return
     */
    Boolean addZSet(String key ,double score, Object value);

    /**
     * 添加有序集合ZSET
     * @param key
     * @param value
     * @return
     */
    Long addZSet(K key,TreeSet&lt;V&gt; value);

    /**
     * 添加有序集合ZSET
     * @param key
     * @param score
     * @param value
     * @return
     */
    Boolean addZSet(K key,double[] score, Object[] value);



}
</code></pre>

<h2>Redis的工具类</h2>

<pre><code class="java Redis的工具类">
package com.uifuture.utils.redis;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.connection.DataType;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ZSetOperations;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;

/**
 * Created with IntelliJ IDEA.
 * User: 陈浩翔.
 * Date: 2017/4/10.
 * Time: 上午 12:51.
 * Explain: Redis的工具类
 * 增删改 -不能在这里面抓取异常 -因为可能有事务处理
 */
@Component
public class RedisHandle implements RedisCommand&lt;String, Object&gt; {
    private Logger logger = Logger.getLogger(RedisHandle.class);
    @Autowired
    protected RedisTemplate redisTemplate;
    /**
     * 出异常，重复操作的次数
     */
    private static Integer times = 5;

    @Override
    public double getCreateTimeScore(long date) {
        return date/ 100000.0;
    }

    @Override
    public Set&lt;String&gt; getAllKeys() {
        return redisTemplate.keys("*");
    }

    @Override
    public Map&lt;String, Object&gt; getAllString() {
        Set&lt;String&gt; stringSet = getAllKeys();
        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
        Iterator&lt;String&gt; iterator = stringSet.iterator();
        while (iterator.hasNext()) {
            String k = iterator.next();
            if (getType(k) == DataType.STRING) {
                map.put(k, get(k));
            }
        }
        return map;
    }

    @Override
    public Map&lt;String, Set&lt;Object&gt;&gt; getAllSet() {
        Set&lt;String&gt; stringSet = getAllKeys();
        Map&lt;String, Set&lt;Object&gt;&gt; map = new HashMap&lt;String, Set&lt;Object&gt;&gt;();
        Iterator&lt;String&gt; iterator = stringSet.iterator();
        while (iterator.hasNext()) {
            String k = iterator.next();
            if (getType(k) == DataType.SET) {
                map.put(k, getSet(k));
            }
        }
        return map;
    }

    @Override
    public Map&lt;String, Set&lt;Object&gt;&gt; getAllZSetRange() {
        Set&lt;String&gt; stringSet = getAllKeys();
        Map&lt;String, Set&lt;Object&gt;&gt; map = new HashMap&lt;String, Set&lt;Object&gt;&gt;();
        Iterator&lt;String&gt; iterator = stringSet.iterator();
        while (iterator.hasNext()) {
            String k = iterator.next();
            if (getType(k) == DataType.ZSET) {
                logger.debug("k:"+k);
                map.put(k, getZSetRange(k));
            }
        }
        return map;
    }

    @Override
    public Map&lt;String, Set&lt;Object&gt;&gt; getAllZSetReverseRange() {
        Set&lt;String&gt; stringSet = getAllKeys();
        Map&lt;String, Set&lt;Object&gt;&gt; map = new HashMap&lt;String, Set&lt;Object&gt;&gt;();
        Iterator&lt;String&gt; iterator = stringSet.iterator();
        while (iterator.hasNext()) {
            String k = iterator.next();
            if (getType(k) == DataType.ZSET) {
                map.put(k, getZSetReverseRange(k));
            }
        }
        return map;
    }

    @Override
    public Map&lt;String, List&lt;Object&gt;&gt; getAllList() {
        Set&lt;String&gt; stringSet = getAllKeys();
        Map&lt;String, List&lt;Object&gt;&gt; map = new HashMap&lt;String, List&lt;Object&gt;&gt;();
        Iterator&lt;String&gt; iterator = stringSet.iterator();
        while (iterator.hasNext()) {
            String k = iterator.next();
            if (getType(k) == DataType.LIST) {
                map.put(k, getList(k));
            }
        }
        return map;
    }

    @Override
    public Map&lt;String, Map&lt;String, Object&gt;&gt; getAllMap() {
        Set&lt;String&gt; stringSet = getAllKeys();
        Map&lt;String, Map&lt;String, Object&gt;&gt; map = new HashMap&lt;String, Map&lt;String, Object&gt;&gt;();
        Iterator&lt;String&gt; iterator = stringSet.iterator();
        while (iterator.hasNext()) {
            String k = iterator.next();
            if (getType(k) == DataType.HASH) {
                map.put(k, getMap(k));
            }
        }
        return map;
    }

    @Override
    public void addList(String key, List&lt;Object&gt; objectList) {
        for (Object obj : objectList) {
            addList(key, obj);
        }
    }

    @Override
    public long addList(String key, Object obj) {
        return redisTemplate.boundListOps(key).rightPush(obj);
    }

    @Override
    public long addList(String key, Object... obj) {
        return redisTemplate.boundListOps(key).rightPushAll(obj);
    }

    @Override
    public List&lt;Object&gt; getList(String key, long s, long e) {
        return redisTemplate.boundListOps(key).range(s, e);
    }

    @Override
    public List&lt;Object&gt; getList(String key) {
        return redisTemplate.boundListOps(key).range(0, getListSize(key));
    }

    @Override
    public long getListSize(String key) {
        return redisTemplate.boundListOps(key).size();
    }

    @Override
    public long removeListValue(String key, Object object) {
        return redisTemplate.boundListOps(key).remove(0, object);
    }

    @Override
    public long removeListValue(String key, Object... objects) {
        long r = 0;
        for (Object object : objects) {
            r += removeListValue(key, object);
        }
        return r;
    }

    @Override
    public void remove(String... key) {
        if (key != null &amp;&amp; key.length &gt; 0) {
            if (key.length == 1) {
                remove(key[0]);
            } else {
                redisTemplate.delete(CollectionUtils.arrayToList(key));
            }
        }
    }

    @Override
    public void removeBlear(String... blears) {
        for (String blear : blears) {
            removeBlear(blear);
        }
    }

    @Override
    public Boolean renameIfAbsent(String oldKey, String newKey) {
        return redisTemplate.renameIfAbsent(oldKey, newKey);
    }

    @Override
    public void removeBlear(String blear) {
        redisTemplate.delete(redisTemplate.keys(blear));
    }

    @Override
    public void removeByRegular(String... blears) {
        for (String blear : blears) {
            removeBlear(blear);
        }
    }

    @Override
    public void removeByRegular(String blear) {
        Set&lt;String&gt; stringSet = getAllKeys();
        for (String s : stringSet) {
            if (Pattern.compile(blear).matcher(s).matches()) {
                redisTemplate.delete(s);
            }
        }
    }

    @Override
    public void removeMapFieldByRegular(String key, String... blears) {
        for (String blear : blears) {
            removeMapFieldByRegular(key, blear);
        }
    }

    @Override
    public void removeMapFieldByRegular(String key, String blear) {
        Map&lt;String, Object&gt; map = getMap(key);
        Set&lt;String&gt; stringSet = map.keySet();
        for (String s : stringSet) {
            if (Pattern.compile(blear).matcher(s).matches()) {
                redisTemplate.boundHashOps(key).delete(s);
            }
        }
    }

    @Override
    public Long removeZSetValue(String key, Object... value) {
        return redisTemplate.boundZSetOps(key).remove(value);
    }

    @Override
    public void removeZSet(String key) {
        removeZSetRange(key, 0L, getZSetSize(key));
    }

    @Override
    public void removeZSetRange(String key, Long start, Long end) {
        redisTemplate.boundZSetOps(key).removeRange(start, end);
    }

    @Override
    public void setZSetUnionAndStore(String key,String key1, String key2) {
        redisTemplate.boundZSetOps(key).unionAndStore(key1,key2);
    }

    @Override
    public Set&lt;Object&gt; getZSetRange(String key) {
        return getZSetRange(key, 0, getZSetSize(key));
    }

    @Override
    public Set&lt;Object&gt; getZSetRange(String key, long s, long e) {
        return redisTemplate.boundZSetOps(key).range(s, e);
    }

    @Override
    public Set&lt;Object&gt; getZSetReverseRange(String key) {
        return getZSetReverseRange(key, 0, getZSetSize(key));
    }

    @Override
    public Set&lt;Object&gt; getZSetReverseRange(String key, long start, long end) {
        return redisTemplate.boundZSetOps(key).reverseRange(start, end);
    }

    @Override
    public Set&lt;Object&gt; getZSetRangeByScore(String key, double start, double end) {
        return redisTemplate.boundZSetOps(key).rangeByScore(start, end);
    }
    @Override
    public Set&lt;Object&gt; getZSetReverseRangeByScore(String key, double start, double end) {
        return redisTemplate.boundZSetOps(key).reverseRangeByScore(start, end);
    }

    @Override
    public Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; getZSetRangeWithScores(String key, long start, long end) {
        return redisTemplate.boundZSetOps(key).rangeWithScores(start, end);
    }

    @Override
    public Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; getZSetReverseRangeWithScores(String key, long start, long end) {
        return redisTemplate.boundZSetOps(key).reverseRangeWithScores(start, end);
    }

    @Override
    public Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; getZSetRangeWithScores(String key) {
        return getZSetRangeWithScores(key, 0, getZSetSize(key));
    }

    @Override
    public Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; getZSetReverseRangeWithScores(String key) {
        return getZSetReverseRangeWithScores(key, 0, getZSetSize(key));
    }

    @Override
    public long getZSetCountSize(String key, double sMin, double sMax) {
        return redisTemplate.boundZSetOps(key).count(sMin, sMax);
    }

    @Override
    public long getZSetSize(String key) {
        return redisTemplate.boundZSetOps(key).size();
    }

    @Override
    public double getZSetScore(String key, Object value) {
        return redisTemplate.boundZSetOps(key).score(value);
    }

    @Override
    public double incrementZSetScore(String key, Object value, double delta) {
        return redisTemplate.boundZSetOps(key).incrementScore(value, delta);
    }

    @Override
    public Boolean addZSet(String key, double score, Object value) {
        return redisTemplate.boundZSetOps(key).add(value, score);
    }

    @Override
    public Long addZSet(String key, TreeSet&lt;Object&gt; value) {
        return redisTemplate.boundZSetOps(key).add(value);
    }

    @Override
    public Boolean addZSet(String key, double[] score, Object[] value) {
        if (score.length != value.length) {
            return false;
        }
        for (int i = 0; i &lt; score.length; i++) {
            if (addZSet(key, score[i], value[i]) == false) {
                return false;
            }
        }
        return true;
    }

    @Override
    public void remove(String key) {
        if (exists(key)) {
            redisTemplate.delete(key);
        }
    }

    @Override
    public void removeZSetRangeByScore(String key,double s , double e) {
        redisTemplate.boundZSetOps(key).removeRangeByScore(s,e);
    }

    @Override
    public Boolean setSetExpireTime(String key, Long time) {
        return redisTemplate.boundSetOps(key).expire(time, TimeUnit.SECONDS);
    }

    @Override
    public Boolean setZSetExpireTime(String key, Long time) {
        return redisTemplate.boundZSetOps(key).expire(time, TimeUnit.SECONDS);
    }

    @Override
    public boolean exists(String key) {
        return redisTemplate.hasKey(key);
    }

    @Override
    public Object get(String key) {
        return redisTemplate.boundValueOps(key).get();
    }

    @Override
    public List&lt;Object&gt; get(String... keys) {
        List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();
        for (String key : keys) {
            list.add(get(key));
        }
        return list;
    }

    @Override
    public List&lt;Object&gt; getByRegular(String regKey) {
        Set&lt;String&gt; stringSet = getAllKeys();
        List&lt;Object&gt; objectList = new ArrayList&lt;Object&gt;();
        for (String s : stringSet) {
            if (Pattern.compile(regKey).matcher(s).matches() &amp;&amp; getType(s) == DataType.STRING) {
                objectList.add(get(s));
            }
        }
        return objectList;
    }

    @Override
    public void set(String key, Object value) {
        redisTemplate.boundValueOps(key).set(value);
    }

    @Override
    public void set(String key, Object value, Long expireTime) {
        redisTemplate.boundValueOps(key).set(value, expireTime, TimeUnit.SECONDS);
    }

    @Override
    public boolean setExpireTime(String key, Long expireTime) {
        return redisTemplate.expire(key, expireTime, TimeUnit.SECONDS);
    }


    @Override
    public DataType getType(String key) {
        return redisTemplate.type(key);
    }


    @Override
    public void removeMapField(String key, Object... field) {
        redisTemplate.boundHashOps(key).delete(field);
    }

    @Override
    public Long getMapSize(String key) {
        return redisTemplate.boundHashOps(key).size();
    }

    @Override
    public Map&lt;String, Object&gt; getMap(String key) {
        return redisTemplate.boundHashOps(key).entries();
    }

    @Override
    public &lt;T&gt; T getMapField(String key, String field) {
        return (T) redisTemplate.boundHashOps(key).get(field);
    }

    @Override
    public Boolean hasMapKey(String key, String field) {
        return redisTemplate.boundHashOps(key).hasKey(field);
    }

    @Override
    public List&lt;Object&gt; getMapFieldValue(String key) {
        return redisTemplate.boundHashOps(key).values();
    }

    @Override
    public Set&lt;Object&gt; getMapFieldKey(String key) {
        return redisTemplate.boundHashOps(key).keys();
    }

    @Override
    public void addMap(String key, Map&lt;String, Object&gt; map) {
        redisTemplate.boundHashOps(key).putAll(map);
    }

    @Override
    public void addMap(String key, String field, Object value) {
        redisTemplate.boundHashOps(key).put(field, value);
    }

    @Override
    public void addMap(String key, String field, Object value, long time) {
        redisTemplate.boundHashOps(key).put(field, value);
        redisTemplate.boundHashOps(key).expire(time, TimeUnit.SECONDS);
    }

    @Override
    public void watch(String key) {
        redisTemplate.watch(key);
    }

    @Override
    public void addSet(String key, Object... obj) {
        redisTemplate.boundSetOps(key).add(obj);
    }

    @Override
    public long removeSetValue(String key, Object obj) {
        return redisTemplate.boundSetOps(key).remove(obj);
    }

    @Override
    public long removeSetValue(String key, Object... obj) {
        if (obj != null &amp;&amp; obj.length &gt; 0) {
            return redisTemplate.boundSetOps(key).remove(obj);
        }
        return 0L;
    }

    @Override
    public long getSetSize(String key) {
        return redisTemplate.boundSetOps(key).size();
    }

    @Override
    public Boolean hasSetValue(String key, Object obj) {
        Boolean boo = null;
        int t =0;
        while (true){
            try {
                boo = redisTemplate.boundSetOps(key).isMember(obj);
                break;
            } catch (Exception e) {
                logger.error("key[" + key + "],obj[" + obj + "]判断Set中的值是否存在失败,异常信息:" + e.getMessage());
                t++;
            }
            if(t&gt;times){
                break;
            }
        }
        logger.info("key[" + key + "],obj[" + obj + "]是否存在,boo:" + boo);
        return boo;
    }

    @Override
    public Set&lt;Object&gt; getSet(String key) {
        return redisTemplate.boundSetOps(key).members();
    }

    @Override
    public Set&lt;Object&gt; getSetUnion(String key, String otherKey) {
        return redisTemplate.boundSetOps(key).union(otherKey);
    }

    @Override
    public Set&lt;Object&gt; getSetUnion(String key, Set&lt;Object&gt; set) {
        return redisTemplate.boundSetOps(key).union(set);
    }

    @Override
    public Set&lt;Object&gt; getSetIntersect(String key, String otherKey) {
        return redisTemplate.boundSetOps(key).intersect(otherKey);
    }

    @Override
    public Set&lt;Object&gt; getSetIntersect(String key, Set&lt;Object&gt; set) {
        return redisTemplate.boundSetOps(key).intersect(set);
    }

}
</code></pre>

<p>这个是我当时写一个Web项目的时候，慢慢整合而成的，比较完整的Redis操作工具类，基本上可以满足你操纵Redis的绝大多数需要了。</p>

<p>因为不是个什么完整的项目，就没有上传到github上为大家提供这几个代码的下载了，只能麻烦需要的朋友直接拷贝下了。</p>

<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
</feed>
