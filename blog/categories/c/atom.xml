<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C | 谙忆-人生之旅]]></title>
  <link href="http://chenhaoxiang.github.io/blog/categories/c/atom.xml" rel="self"/>
  <link href="http://chenhaoxiang.github.io/"/>
  <updated>2017-09-15T10:38:15+08:00</updated>
  <id>http://chenhaoxiang.github.io/</id>
  <author>
    <name><![CDATA[陈浩翔]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++栈和队列]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2015/08/28/C-plus-plusThe-stack-and-queue/"/>
    <updated>2015-08-28T10:46:04+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2015/08/28/C-plus-plusThe-stack-and-queue</id>
    <content type="html"><![CDATA[<p>c++栈和队列的操作以及实例</p>

<!-- more -->


<hr />

<p>使用标准库的栈和队列时，先包含相关的头文件</p>

<pre><code>#include&lt;stack&gt;
#include&lt;queue&gt;
</code></pre>

<p>定义栈如下：</p>

<pre><code>stack&lt;int&gt; stk;
</code></pre>

<p>定义队列如下：</p>

<pre><code>queue&lt;int&gt; q;
</code></pre>

<p>栈提供了如下的操作</p>

<pre><code>s.empty()               如果栈为空返回true，否则返回false  
s.size()                返回栈中元素的个数  
s.pop()                 删除栈顶元素但不返回其值  
s.top()                 返回栈顶的元素，但不删除该元素  
s.push()                在栈顶压入新元素  
</code></pre>

<p>队列提供了下面的操作</p>

<pre><code>
q.empty()               如果队列为空返回true，否则返回false  
q.size()                返回队列中元素的个数  
q.pop()                 删除队列首元素但不返回其值  
q.front()               返回队首元素的值，但不删除该元素  
q.push()                在队尾压入新元素  
q.back()                返回队列尾元素的值，但不删除该元素  
</code></pre>

<p>c++stack(堆栈）</p>

<p>它是一个容器的改编，它实现了一个先进后出的数据结构（FILO）</p>

<p>使用该容器时需要包含#include头文件；</p>

<p>定义stack对象的示例代码如下：</p>

<p>stacks1;</p>

<p>stacks2;</p>

<p>stack的基本操作有：</p>

<p>1.入栈：如s.push(x);</p>

<p>2.出栈:如 s.pop().注意：出栈操作只是删除栈顶的元素，并不返回该元素。</p>

<p>3.访问栈顶：如s.top();</p>

<p>4.判断栈空：如s.empty().当栈空时返回true。</p>

<p>5.访问栈中的元素个数，如s.size（）;</p>

<p>下面举一个简单的例子：</p>

<pre><code class="c++">  #include&lt;iostream&gt;  
    #include&lt;stack&gt;  
    using namespace std;  
    int main(void)  
    {  
        stack&lt;double&gt;s;//定义一个栈  
        for(int i=0;i&lt;10;i++)  
            s.push(i);  
        while(!s.empty())  
        {  
            printf("%lf\n",s.top());  
            s.pop();  
        }  
        cout&lt;&lt;"栈内的元素的个数为："&lt;&lt;s.size()&lt;&lt;endl; 
    }
</code></pre>

<p>栈是限定仅在表尾进行插入或删除操作的线性表，<br/>
因此表尾端成为栈顶，相应的，表头端成为栈底，不含有任何元素的栈称为空栈。<br/>
栈的修改遵循后进先出的原则，因此栈又称为后进先出的线性表，简称LIFO结构。<br/>
栈一般采用数组作为其存储结构，这样做可以避免使用指针，简化程序<br/>
，当然数组需要预先声明静态数据区的大小，但这不是问题，因为即便是频繁进出入栈操作，<br/>
任何时刻栈元素的实际个数也不会很多，为栈预留一个足够大但又不占用太多空间并不是很困难，<br/>
如果不能做到这一点，那么节省内存的方法就是使用链表存储栈。</p>

<p>线性表实现栈的基本操作<br/>
```c++
    #include<iostream><br/>
    #include<cstdio><br/>
    using namespace std;<br/>
    typedef struct Stacknode//定义链式栈的结构体<br/>
    {<br/>
        int data;//数据域<br/>
        Stacknode <em>next;//下一节点的指针域<br/>
    }Stacknode,</em>Stack;<br/>
    //初始化一个链式栈（返回一个链式栈的头节点）<br/>
    Stack InitStack()<br/>
    {<br/>
        Stack stack=(Stack)malloc(sizeof(Stacknode));<br/>
        stack->next=NULL;<br/>
        return stack;<br/>
    }<br/>
    //入栈<br/>
    void Push(Stack stack,int newData)<br/>
    {<br/>
        //判断是否为空<br/>
        if(stack==NULL)<br/>
        {<br/>
            printf(&ldquo;栈未初始化，请初始化以后再使用\n&rdquo;);<br/>
            return;<br/>
        }<br/>
        //找到最后一个节点<br/>
       Stacknode <em>lastnode=stack;<br/>
       while(lastnode->next)<br/>
        {<br/>
        lastnode=lastnode->next;<br/>
        }<br/>
       lastnode->next=(Stacknode</em>)malloc(sizeof(Stacknode<em>));<br/>
       lastnode->next->data=newData;<br/>
       lastnode->next->next=NULL;<br/>
       printf(&ldquo;入栈成功！\n&rdquo;);<br/>
    }<br/>
    //出栈<br/>
    int Pop(Stack stack)<br/>
    {<br/>
        //判断栈是否为空<br/>
        if(!stack->next)<br/>
        {<br/>
            printf(&ldquo;栈为空，无法出栈\n&rdquo;);<br/>
            return -1;//-1只是一个自定义的错误代码<br/>
        }<br/>
        //找到最后一个节点的钱一个节点<br/>
        //tempNode:最后一个节点的前一个节点<br/>
        Stacknode </em>tempNode=stack;<br/>
        while(tempNode->next->next)<br/>
        {<br/>
            tempNode=tempNode->next;<br/>
        }<br/>
        int data=tempNode->next->data;<br/>
        free(tempNode->next);<br/>
        tempNode->next=NULL;<br/>
        return data;<br/>
    }</p>

<pre><code>int main()  
{  
    Stack stack=InitStack();  
    Push(stack,3);//3进栈  
    Push(stack,4);//4进栈  
    Push(stack,5);//5进栈  
    printf("%d\n",Pop(stack));  
    printf("%d\n",Pop(stack));  
    printf("%d\n",Pop(stack));  
    printf("%d\n",Pop(stack));//第4次出栈，应该出错  
    return 0;  
}  
</code></pre>

<pre><code>queue模版类的定义在&lt;queue&gt;头文件中。  
queue与stack模版非常类似，queue模版也需要定义两个模版参数，  
一个是元素类型，一个是容器类型，元素类型是必要的，  
容器类型是可选的，默认为dqueue类型。  

定义queue对象的示例代码如下：  
</code></pre>

<p>queue<int>q1;
queue<double>q2;
```
queue的基本操作有：<br/>
1.入队：如q.push(x):将x元素接到队列的末端；<br/>
2.出队：如q.pop() 弹出队列的第一个元素，并不会返回元素的值；<br/>
3,访问队首元素：如q.front()<br/>
4,访问队尾元素，如q.back();<br/>
5,访问队中的元素个数，如q.size();<br/>
二.优先队列<br/>
在<queue>头文件中，还定义了一个非常有用的模版类priority_queue<br/>
(优先队列），优先队列与队列的差别在于优先队列不是按照入队的顺序出队，<br/>
而是按照队列中元素的优先权顺序出队（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）默认是一个大根堆。<br/>
priority_queue模版类有三个模版参数，元素类型，容器类型，比较算子。<br/>
其中后两个都可以省略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队时序列尾的元素出队）。</p>

<p>定义priority_queue对象的示例代码如下：<br/>
<code>c++
priority_queue&lt;int&gt;q1;
priority_queue&lt;pair&lt;int,int&gt; &gt;q2;
priority_queue&lt;int,vector&lt;int&gt;，greater&lt;int&gt; &gt;q3;
</code>
//定义小的先出队<br/>
priority_queue的基本操作均与queue相同<br/>
初学者在使用priority_queue时，最困难的可能就是如何定义比较算子了。<br/>
如果是基本数据类型，或已定义了比较运算符的类，可以直接用STL的less算子和greater算子——默认为使用less算子，<br/>
即小的往前排，大的先出队。如果要定义自己的比较算子，方法有多种，<br/>
这里介绍其中的一种：重载比较运算符。优先队列试图将两个元素x和y代入比较运算符<br/>
(对less算子，调用x&lt;y，对greater算子，调用x>y)，若结果为真，则x排在y前面，y将先于x出队，反之，则将y排在x前面，x将先出队。</p>

<p>看下面这个简单的示例：<br/>
<code>c++
    #include&lt;iostream&gt;  
    #include&lt;queue&gt;  
    #include&lt;stdlib.h&gt;  
    using namespace std;  
    class T  
    {  
    public:  
        int x,y,z;  
        T(int a,int b,int c):x(a),y(b),z(c)  
        {  
        }  
    };  
    bool operator&lt;(const T&amp;t1,const T&amp;t2)  
    {  
        return t1.z&lt;t2.z; int="" t=""&gt;q;  
        q.push(T(4,4,3));  
        q.push(T(2,2,5));  
        q.push(T(1,5,4));  
        q.push(T(3,3,6));  
        while(!q.empty())  
        {  
            T t=q.top();  
            q.pop();  
            cout&lt;&lt;t.x&lt;&lt;endl;  
        }
     }
</code></p>

<p>栈的应用</p>

<p>①数制转换：</p>

<p>将一个非负的十进制整数N转换为另一个等价的基为B的B进制数的问题，很容易通过"除B取余法"来解决。</p>

<p>【例】将十进制数13转化为二进制数。<br/>
解答：按除2取余法，得到的余数依次是1、0、1、1，则十进制数转化为二进制数为1101。<br/>
分析：由于最先得到的余数是转化结果的最低位，最后得到的余数是转化结果的最高位，因此很容易用栈来解决。</p>

<p>具体算法如下：</p>

<pre><code class="C++">#include &lt;STACK&gt;    //C++中使用栈要包含的头文件
using namespace std;//这个也是要加的

void conversion(int N,int B)
{//假设N是非负的十进制整数，输出等值的B进制数

  stack&lt;int&gt; S;        //创建一个元素类型为int型的空栈
  while(N)
  {
    S.push(N%B); //将转换后的数值，从底位到高位开始入栈
    N=N/B;
  }
  while(!S.empty())//栈非空时退栈输出
  {
    printf("%d",S.top());    //打印栈顶元素
    S.pop();    //将栈顶元素出栈
  }
}

int main()
{
  conversion(10,2);
}
</code></pre>

<p>②表达式求值</p>

<p>表达式求值是程序设计语言编译中的一个最基本的问题。我们讨论一种简单直观的方法“算法优先级法”</p>

<p>算术四则运算的规则：</p>

<p>1、从左到右</p>

<p>2、先乘除后加减</p>

<p>3、先括号内，后括号外<br/>
【例】4 + 2*3 -10/5 每一步的计算顺序应该是：</p>

<p>4 + 2*3 -10/5 = 4 + 6 - 10/5 = 10 - 10/5 = 10 - 2 = 8</p>

<p>算法步骤：（我们假设表达式以字符‘#’结尾）</p>

<p>（1）首先，创建空运算符栈OPTR，将表达式起始符‘#’压入栈底，创建空操作数栈OPND</p>

<p>（2）依次读入表达式中的每个字符，若是操作数则进操作数栈，若是运算符则和运算符栈顶的运算符比较优先级后，做如下相应操作：</p>

<p>1.如果栈顶的运算符优先级较低，则把新的运算符压入OPTR；执行（2）</p>

<p>2.如果栈顶的运算符优先级较高，则将其 和 操作数栈的两个栈顶元素 退栈，计算3个元素组成的表达式的值，再压入操作数栈，然后继续判断；</p>

<p>3.如果栈顶的运算符优先级相等（除了#符外，只有‘(’和‘)’是相等的），则将‘（’出栈；执行（2）</p>

<p>（3）直到整个表达式求值完毕（即OPTR栈顶元素和当前读入的字符均为‘#’）</p>

<p>具体算法实现：</p>

<pre><code class="c++">#include &lt;iostream&gt;   
#include &lt;stack&gt;//C++中使用栈要包含的头文件

using namespace std;

//符号数组   
char symbol[7] = {'+', '-', '*', '/', '(', ')', '#'};  

//栈内元素的优先级   
int in[7] = {3, 3, 5, 5, 1, 6, 0};  

//栈外元素的优先级   
int out[7] = {2, 2, 4, 4, 6, 1, 0};  

/* 
 * 通过符号字符获取它的数组下标 
 */ 
int get(char c)  
{  
  switch(c)  
  {  
  case '+':  
    return 0;  
  case '-':  
    return 1;  
  case '*':  
    return 2;  
  case  '/':  
    return 3;  
  case '(':  
    return 4;  
  case ')':  
    return 5;  
  case '#':  
    return 6;  
  default:   
    return 6;  
  }  
}  

/* 
 * 比较栈内运算符c1和栈外运算符c2的优先级 
 */ 
char precede(char c1, char c2)  
{  
  int i1 = get(c1);  
  int i2 = get(c2);  

  if(in[i1] &gt; out[i2])  
  {  
    return '&gt;';  
  }  
  else if(in[i1] &lt; out[i2])  
  {  
    return '&lt;';  
  }  
  else 
  {  
    return '=';  
  }  
}  

/* 
 * 计算基本表达式的值 
 */ 
int figure(int a, int theta, int b)  
{  
  switch(theta)  
  {  
  case 0:  
    return a + b;  
  case 1:  
    return a - b;  
  case 2:  
    return a * b;  
  default:  
    return a / b;  
  }  
}  

/* 
 * 计算表达式的值 
 */ 
int EvaluateExpression(const char *exp)  
{  
  stack&lt;int&gt; OPND; //操作数栈   
  stack&lt;int&gt; OPTR; //运算符栈   
  OPTR.push(get('#'));

  int flag = 1; //表示正负号 1,表示正 0,表示负   
  int a, theta, b;  

  if(!('+' == *exp || '-' == *exp || '(' == *exp || isdigit(*exp)))  
  {//如果不是以'+'、'-'、'('或者数字的其中一个开头，则表达式错误  
    cout &lt;&lt; "表达式出错1" &lt;&lt; endl;  
    return -1;  
  }  
  if('+' == *exp)  
  {   
    exp++;//指向下一个字符   
  }
  else if('-' == *exp)  
  {  
    flag = 0;  
    exp++;//指向下一个字符   
  }  

  int index = OPTR.top();                //获取运算符栈顶元素在数组的下标号
  while(*exp || symbol[index] != '#') //如果栈顶元素是'#'且当前元素为空结束计算 
  {  
    if(isdigit(*exp))  
    {//如果当前元素是数字，计算整个操作数的值，然后压入操作数栈
      int sum = 0; 
      while(isdigit(*exp))  
      {//计算操作数的值
        sum = sum * 10 + (*exp - '0');  
        exp++;  
      }
      if (!flag)    //如果是负数
      {
        sum = -sum;
      }
      OPND.push(sum);  
      flag = 1;  
    }  
    else 
    {//如果不是数字
      switch(precede(symbol[OPTR.top()], *exp))//比较栈顶运算符和当前运算符的优先级
      {  
      case '&gt;' :  
        b = OPND.top();
        OPND.pop();
        a = OPND.top();  
        OPND.pop();  
        theta = OPTR.top();  
        OPTR.pop();  
        OPND.push(figure(a, theta, b));  
        break;  
      case '&lt;' :  
        OPTR.push(get(*exp));  
        if(*exp)  
        {  
          exp++;  
        }  
        break;  
      case '=' :  
        OPTR.pop();  
        if(*exp)  
        {  
          exp++;  
        }  
        break;  
      }  
    }
    index = OPTR.top();
  }  
  return OPND.top();  
}  

int main()  
{
  char c[50] = {0};
  cout &lt;&lt; "请输入一个表达式: ";
  cin.getline(c,50);
  cout &lt;&lt; EvaluateExpression(c) &lt;&lt; endl;  

  return 0;  
}
</code></pre>

<p>队列的应用</p>

<p>舞伴问题</p>

<p>1、问题叙述<br/>
假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。若两队初始人数不相同，则较长的那一队中未配对者，等待下一轮舞曲。现要求写一算法模拟上述舞伴配对问题。<br/>
2、问题分析<br/>
先入队的男士或女士亦先出队配成舞伴。因此该问题具体有典型的先进先出特性，可用队列作为算法的数据结构。<br/>
在算法中，假设男士和女士的记录存放在一个数组中作为输入，然后依次扫描该数组的各元素，并根据性别来决定是进入男队还是女队。当这两个队列构造完成之后，依次将两队当前的队头元素出队来配成舞伴，直至某队列变空为止。此时，若某队仍有等待配对者，算法输出此队列中等待者的人数及排在队头的等待者的名字，他（或她）将是下一轮舞曲开始时第一个可获得舞伴的人。<br/>
3、具体算法及相关的类型定义</p>

<pre><code class="c++">#include &lt;queue&gt; 
//C++中使用队列要包含的头文件
using namespace std;
typedef struct
{
  char name[20];
  char sex; //性别，'F'表示女性，'M'表示男性
}Person;

void DancePartner(Person dancer[],int num)
{//结构数组dancer中存放跳舞的男女，num是跳舞的人数。

  Person p;
  queue&lt;Person&gt; Mdancers,Fdancers;

  for(int i = 0; i &lt; num; i++)
  {//依次将跳舞者依其性别入队
    p=dancer[i]; 
    if(p.sex=='F')
      Fdancers.push(p); //排入女队
    else
      Mdancers.push(p); //排入男队
  }
  printf("The dancing partners are: \n \n");
  while(!(Fdancers.empty()||Mdancers.empty()))
  {
    //依次输入男女舞伴名
    p=Fdancers.front();        //获取女队第一人
    Fdancers.pop();            //出队
    printf("%s ",p.name);    //打印出队女士名

    p=Mdancers.front();        //获取男队第一人
    Mdancers.pop();            //出队
    printf("%s\n",p.name);    //打印出队男士名
  }
  if(!Fdancers.empty())
  {//输出女士剩余人数及队头女士的名字
    printf("\n There are %d women waitin for the next round.\n",Fdancers.size());
    p=Fdancers.front(); //取队头
    printf("%s will be the first to get a partner. \n",p.name);
  }
  else if(!Mdancers.empty())
  {//输出男队剩余人数及队头者名字
    printf("\n There are%d men waiting for the next round.\n",Mdancers.size());
    p=Mdancers.front();
    printf("%s will be the first to get a partner.\n",p.name);
  }
  else
  {
    printf("There is not person in the queue!");
  }
}//DancerPartners

int main()
{
  Person p[] = { {"A",'F'},{"B",'F'},{"C",'M'},{"D",'M'} };
  DancePartner(p,4);
}
</code></pre>

<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言运算符号详细说明]]></title>
    <link href="http://chenhaoxiang.github.io/blog/2015/08/27/C-language-sign-of-operation-in-detail/"/>
    <updated>2015-08-27T04:20:47+08:00</updated>
    <id>http://chenhaoxiang.github.io/blog/2015/08/27/C-language-sign-of-operation-in-detail</id>
    <content type="html"><![CDATA[<p>C语言中具有右结合性的运算符包括所有单目运算符以及赋值运算符（=）和条件运算符。其它都是左结合性。</p>

<p>判断表达式计算顺序时，先按优先级高的先计算，优先级低的后计算，当优先级相同时再按结合性，或从左至右顺序计算，或从右至左顺序计算。</p>

<!-- more -->


<hr />

<p>C语言中的符号<br/>
运算符的种类<br/>
语言的运算符可分为以下几类：</p>

<p>1 算术运算符<br/>
用于各类数值运算。包括加(+)、减(-)、乘(*)、除(/)、求余(或称模运算，%)、自增(++)、自减(&ndash;)共七种。</p>

<p>2.关系运算符<br/>
用于比较运算。包括大于(>)、小于(&lt;)、等于(==)、 大于等于(>=) 、小于等于(&lt;=)和不等于(!=)六种。</p>

<p>3.逻辑运算符<br/>
用于逻辑运算。包括与(&amp;&amp;)、或(||)、非(!)三种。</p>

<p>4.位操作运算符
参与运算的量，按二进制位进行运算。包括位与(&amp;)、位或(|)、位非(~)、位异或(^)、左移(&lt;&lt;)、右移(>>)六种。</p>

<p>5.赋值运算符<br/>
用于赋值运算，分为简单赋值(=)、复合算术赋值(+=,-=,*=,/=,%=)和复合位运算赋值(&amp;=,|=,^=,>>=,&lt;&lt;=)三类共十一种。</p>

<p>6.条件运算符<br/>
这是一个三目运算符，用于条件求值(?:)。</p>

<p>7.逗号运算符<br/>
用于把若干表达式组合成一个表达式(，)。</p>

<p>8.指针运算符<br/>
用于取内容(*)和取地址(&amp;)二种运算。</p>

<p>9.求字节数运算符<br/>
用于计算数据类型所占的字节数(sizeof)。</p>

<p>10.特殊运算符<br/>
有括号()，下标[]，成员(→，.)等几种。</p>

<p>优先级排序：<br/>
```
优先级1级 结合方向 左结合（自左至右）编辑
( ) 圆括号
[ ] [1]  下标运算符
-> 指向结构体成员运算符
. 结构体成员运算符[1]  （请注意它是一个实心圆点）</p>

<p>优先级2级 结合方向 右结合（自右至左）单目运算符编辑
! 逻辑非运算符
~ 按位取反运算符
++ 自增运算符
&ndash; 自减运算符
- 负号运算符
(类型) 类型转换运算符
* 指针运算符
&amp; 地址与运算符
sizeof 长度运算符</p>

<p>优先级3级 结合方向 左结合 双目运算符编辑
* 乘法运算符
/ 除法运算符
% 取余运算符</p>

<p>优先级4级 结合方向 左结合 双目运算符编辑
+ 加法运算符
- 减法运算符</p>

<p>优先级5级 结合方向 左结合 双目运算符编辑
&lt;&lt; 左移运算符</p>

<blockquote><blockquote><p>右移运算符</p></blockquote></blockquote>

<p>优先级6级 结合方向 左结合 双目运算符编辑
&lt;、&lt;=、>、>= 关系运算符</p>

<p>优先级7级 结合方向 左结合 双目运算符编辑
== 等于运算符 （判断）
!= 不等于运算符（判断）</p>

<p>优先级8级 结合方向 左结合 双目运算符编辑
&amp; 按位与运算符</p>

<p>优先级9级 结合方向 左结合 双目运算符编辑
^ 按位异或运算符</p>

<p>优先级10级 结合方向 左结合 双目运算符编辑
| 按位或运算符 举例：0xfe|0xef 即为1111 1110 与1110 1111按位或运算则答案为：1111 1111 即0xff。</p>

<p>优先级11级 结合方向 左结合 双目运算符编辑
&amp;&amp; 逻辑与运算符</p>

<p>优先级12级 结合方向 左结合 双目运算符编辑
|| 逻辑或运算符</p>

<p>优先级13级 结合方向 右结合 三目运算符编辑
? : 条件运算符</p>

<p>优先级14级 结合方向 右结合 双目运算符编辑
= 赋值运算符
+ = 加后赋值运算符 如s+=1表示s=s+1
- = 减后赋值运算符 如s-=1表示s=s-1
* = 乘后赋值运算符
/ = 除后赋值运算符
% = 取模后赋值运算符
&lt; &lt;= 左移后赋值运算符</p>

<blockquote><blockquote><p>=右移后赋值运算符
&amp;= 按位与后赋值运算符
^=按位异或后赋值运算符
|= 按位或后赋值运算符</p></blockquote></blockquote>

<p>优先级15级 结合方向 左结合编辑
， 逗号运算符
```</p>

<p>说明：<br/>
同一优先级的运算符，运算次序由结合方向所决定。<br/>
简单记就是：！ > 算术运算符 > 关系运算符 > &amp;&amp; > || > 赋值运算符</p>

<p>本文章由<a href="http://chenhaoxiang.cn/">[谙忆]</a>编写， 所有权利保留。
欢迎转载，分享是进步的源泉。</p>

<blockquote cite='陈浩翔'>
<p background-color='#D3D3D3'>转载请注明出处：<a href='http://chenhaoxiang.cn'><font color="green">http://chenhaoxiang.cn</font></a><br><br>
本文源自<strong>【<a href='http://chenhaoxiang.cn' target='_blank'>人生之旅_谙忆的博客</a>】</strong></p>
</blockquote>

]]></content>
  </entry>
  
</feed>
